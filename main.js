/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// lib/codemirror.js
var require_codemirror = __commonJS({
  "lib/codemirror.js"(exports, module2) {
    module2.exports = CodeMirror;
  }
});

// mode/simple/simple.js
var require_simple = __commonJS({
  "mode/simple/simple.js"(exports, module2) {
    (function(mod) {
      if (typeof exports == "object" && typeof module2 == "object")
        mod(require_codemirror());
      else if (typeof define == "function" && define.amd)
        define(["../../lib/codemirror"], mod);
      else
        mod(CodeMirror);
    })(function(CodeMirror3) {
      "use strict";
      CodeMirror3.defineSimpleMode = function(name, states) {
        CodeMirror3.defineMode(name, function(config) {
          return CodeMirror3.simpleMode(config, states);
        });
      };
      CodeMirror3.simpleMode = function(config, states) {
        ensureState(states, "start");
        var states_ = {}, meta = states.meta || {}, hasIndentation = false;
        for (var state in states)
          if (state != meta && states.hasOwnProperty(state)) {
            var list = states_[state] = [], orig = states[state];
            for (var i = 0; i < orig.length; i++) {
              var data = orig[i];
              list.push(new Rule(data, states));
              if (data.indent || data.dedent)
                hasIndentation = true;
            }
          }
        var mode = {
          startState: function() {
            return {
              state: "start",
              pending: null,
              local: null,
              localState: null,
              indent: hasIndentation ? [] : null
            };
          },
          copyState: function(state2) {
            var s = {
              state: state2.state,
              pending: state2.pending,
              local: state2.local,
              localState: null,
              indent: state2.indent && state2.indent.slice(0)
            };
            if (state2.localState)
              s.localState = CodeMirror3.copyState(state2.local.mode, state2.localState);
            if (state2.stack)
              s.stack = state2.stack.slice(0);
            for (var pers = state2.persistentStates; pers; pers = pers.next)
              s.persistentStates = {
                mode: pers.mode,
                spec: pers.spec,
                state: pers.state == state2.localState ? s.localState : CodeMirror3.copyState(pers.mode, pers.state),
                next: s.persistentStates
              };
            return s;
          },
          token: tokenFunction(states_, config),
          innerMode: function(state2) {
            return state2.local && { mode: state2.local.mode, state: state2.localState };
          },
          indent: indentFunction(states_, meta)
        };
        if (meta) {
          for (var prop in meta)
            if (meta.hasOwnProperty(prop))
              mode[prop] = meta[prop];
        }
        return mode;
      };
      function ensureState(states, name) {
        if (!states.hasOwnProperty(name))
          throw new Error("Undefined state " + name + " in simple mode");
      }
      function toRegex(val, caret) {
        if (!val)
          return /(?:)/;
        var flags = "";
        if (val instanceof RegExp) {
          if (val.ignoreCase)
            flags = "i";
          if (val.unicode)
            flags += "u";
          val = val.source;
        } else {
          val = String(val);
        }
        return new RegExp((caret === false ? "" : "^") + "(?:" + val + ")", flags);
      }
      function asToken(val) {
        if (!val)
          return null;
        if (val.apply)
          return val;
        if (typeof val == "string")
          return val.replace(/\./g, " ");
        var result = [];
        for (var i = 0; i < val.length; i++)
          result.push(val[i] && val[i].replace(/\./g, " "));
        return result;
      }
      function Rule(data, states) {
        if (data.next || data.push)
          ensureState(states, data.next || data.push);
        this.regex = toRegex(data.regex);
        this.token = asToken(data.token);
        this.data = data;
      }
      function tokenFunction(states, config) {
        return function(stream, state) {
          if (state.pending) {
            var pend = state.pending.shift();
            if (state.pending.length == 0)
              state.pending = null;
            stream.pos += pend.text.length;
            return pend.token;
          }
          if (state.local) {
            if (state.local.end && stream.match(state.local.end)) {
              var tok = state.local.endToken || null;
              state.local = state.localState = null;
              return tok;
            } else {
              var tok = state.local.mode.token(stream, state.localState), m;
              if (state.local.endScan && (m = state.local.endScan.exec(stream.current())))
                stream.pos = stream.start + m.index;
              return tok;
            }
          }
          var curState = states[state.state];
          for (var i = 0; i < curState.length; i++) {
            var rule = curState[i];
            var matches = (!rule.data.sol || stream.sol()) && stream.match(rule.regex);
            if (matches) {
              if (rule.data.next) {
                state.state = rule.data.next;
              } else if (rule.data.push) {
                (state.stack || (state.stack = [])).push(state.state);
                state.state = rule.data.push;
              } else if (rule.data.pop && state.stack && state.stack.length) {
                state.state = state.stack.pop();
              }
              if (rule.data.mode)
                enterLocalMode(config, state, rule.data.mode, rule.token);
              if (rule.data.indent)
                state.indent.push(stream.indentation() + config.indentUnit);
              if (rule.data.dedent)
                state.indent.pop();
              var token = rule.token;
              if (token && token.apply)
                token = token(matches);
              if (matches.length > 2 && rule.token && typeof rule.token != "string") {
                for (var j = 2; j < matches.length; j++)
                  if (matches[j])
                    (state.pending || (state.pending = [])).push({ text: matches[j], token: rule.token[j - 1] });
                stream.backUp(matches[0].length - (matches[1] ? matches[1].length : 0));
                return token[0];
              } else if (token && token.join) {
                return token[0];
              } else {
                return token;
              }
            }
          }
          stream.next();
          return null;
        };
      }
      function cmp(a, b) {
        if (a === b)
          return true;
        if (!a || typeof a != "object" || !b || typeof b != "object")
          return false;
        var props = 0;
        for (var prop in a)
          if (a.hasOwnProperty(prop)) {
            if (!b.hasOwnProperty(prop) || !cmp(a[prop], b[prop]))
              return false;
            props++;
          }
        for (var prop in b)
          if (b.hasOwnProperty(prop))
            props--;
        return props == 0;
      }
      function enterLocalMode(config, state, spec, token) {
        var pers;
        if (spec.persistent) {
          for (var p = state.persistentStates; p && !pers; p = p.next)
            if (spec.spec ? cmp(spec.spec, p.spec) : spec.mode == p.mode)
              pers = p;
        }
        var mode = pers ? pers.mode : spec.mode || CodeMirror3.getMode(config, spec.spec);
        var lState = pers ? pers.state : CodeMirror3.startState(mode);
        if (spec.persistent && !pers)
          state.persistentStates = { mode, spec: spec.spec, state: lState, next: state.persistentStates };
        state.localState = lState;
        state.local = {
          mode,
          end: spec.end && toRegex(spec.end),
          endScan: spec.end && spec.forceEnd !== false && toRegex(spec.end, false),
          endToken: token && token.join ? token[token.length - 1] : token
        };
      }
      function indexOf(val, arr) {
        for (var i = 0; i < arr.length; i++)
          if (arr[i] === val)
            return true;
      }
      function indentFunction(states, meta) {
        return function(state, textAfter, line) {
          if (state.local && state.local.mode.indent)
            return state.local.mode.indent(state.localState, textAfter, line);
          if (state.indent == null || state.local || meta.dontIndentStates && indexOf(state.state, meta.dontIndentStates) > -1)
            return CodeMirror3.Pass;
          var pos = state.indent.length - 1, rules = states[state.state];
          scan:
            for (; ; ) {
              for (var i = 0; i < rules.length; i++) {
                var rule = rules[i];
                if (rule.data.dedent && rule.data.dedentIfLineStart !== false) {
                  var m = rule.regex.exec(textAfter);
                  if (m && m[0]) {
                    pos--;
                    if (rule.next || rule.push)
                      rules = states[rule.next || rule.push];
                    textAfter = textAfter.slice(m[0].length);
                    continue scan;
                  }
                }
              }
              break;
            }
          return pos < 0 ? 0 : state.indent[pos];
        };
      }
    });
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Neorg
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_codemirror = __toESM(require_codemirror());
var import_simple = __toESM(require_simple());
var import_view = require("@codemirror/view");
var import_codemirror2 = __toESM(require_codemirror());
import_codemirror2.default.defineSimpleMode("neorg", {
  start: [
    { regex: /^\* .*$/, token: ["header-1", "header"], sol: true },
    { regex: /^\*\* .*/, token: ["header-2", "header"], sol: true },
    { regex: /^\*\*\* .*/, token: ["header-3", "header"], sol: true },
    { regex: /^\*\*\*\* .*/, token: ["header-4", "header"], sol: true },
    { regex: /^\s*\~.*$/, token: ["list-item"], sol: true },
    { regex: "/(.*?)/", token: ["italic"] },
    { regex: /\*(.*?)\*/, token: ["bold"] },
    { regex: /`([^`]+)`/, token: ["inline-code"] },
    { regex: /^\s*- \( \)/, token: ["task todo"], sol: true },
    { regex: /^\s*- \(-\)/, token: ["task pending"], sol: true },
    { regex: /^\s*- \(x\)/, token: ["task done"], sol: true }
  ],
  env: [
    { regex: /\#\+(?:(END|end))_[a-zA-Z]*/, token: "comment", next: "start", sol: true },
    { regex: /.*/, token: "comment" }
  ]
});
var Neorg = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.neorgViewCreator = (leaf) => {
      return new NeorgView(leaf);
    };
  }
  async onload() {
    super.onload();
    console.log("Loading Neorg plugin ...");
    this.registerView("neorg", this.neorgViewCreator);
    this.registerExtensions(["norg"], "neorg");
    this.addRibbonIcon("plus", "New norg file", () => {
    });
  }
  newNeorgFile() {
    this.app.vault.create("untitled2.norg", "").then((file) => {
      var _a;
      return (_a = this.app.workspace.getMostRecentLeaf()) == null ? void 0 : _a.openFile(file);
    });
  }
  onunload() {
    console.log("Unloading Neorg plugin ...");
  }
};
var NeorgView = class extends import_obsidian.TextFileView {
  constructor(leaf) {
    super(leaf);
    this.changed = async () => {
      this.requestSave();
      this.reloadButtons();
    };
    this.getViewData = () => {
      return this.codeMirror.getValue();
    };
    this.setViewData = (data, clear) => {
      if (clear) {
        this.codeMirror.swapDoc(import_codemirror2.default.Doc(data, "neorg"));
      } else {
        this.codeMirror.setValue(data);
      }
      this.codeMirror.refresh();
      this.codeMirror.focus();
      this.reloadButtons();
    };
    this.clear = () => {
      this.codeMirror.setValue("");
      this.codeMirror.clearHistory();
    };
    this.codeMirror = (0, import_codemirror2.default)(this.extContentEl, {
      showCursorWhenSelecting: true
    });
    this.codeMirror.on("changes", this.changed);
  }
  // this.contentEl is not exposed, so cheat a bit.
  get extContentEl() {
    return this.contentEl;
  }
  // When the view is resized, refresh CodeMirror (thanks Licat!).
  onResize() {
    this.codeMirror.refresh();
    this.reloadButtons();
  }
  reloadButtons() {
    var _a;
    const todoElements = this.contentEl.querySelectorAll(".task");
    todoElements.forEach((todoElement) => {
      todoElement.remove();
    });
    var rect = this.codeMirror.getWrapperElement().getBoundingClientRect();
    var topVisibleLine = this.codeMirror.lineAtHeight(rect.top, "window");
    var bottomVisibleLine = this.codeMirror.lineAtHeight(rect.bottom, "window");
    for (let i = topVisibleLine; i < bottomVisibleLine; i++) {
      let tokens = this.codeMirror.getLineTokens(i);
      for (let j = 0; j < tokens.length; j++) {
        if ((_a = tokens[j].type) == null ? void 0 : _a.startsWith("task")) {
          this.todoButton(tokens[j], i);
        }
      }
    }
  }
  todoButton(token, line) {
    let lines = this.contentEl.querySelector(".CodeMirror-lines");
    if (lines) {
      let button = lines.createEl("input");
      button.type = "checkbox";
      button.className = token.type;
      const coords = this.codeMirror.charCoords({ line, ch: token.start }, "local");
      button.style.left = coords.left.toString() + "px";
      button.style.top = coords.top.toString() + "px";
      console.log(token.type);
      button.checked = token.type == "task done";
      let cm = this.codeMirror;
      button.addEventListener("change", () => {
        const newText = button.checked ? "- (x)" : "- ( )";
        this.codeMirror.replaceRange(newText, { line, ch: token.start }, { line, ch: token.end });
      });
    }
  }
  getDisplayText() {
    if (this.file) {
      return this.file.basename;
    } else {
      return "org (No File)";
    }
  }
  canAcceptExtension(extension) {
    return extension === "norg";
  }
  getViewType() {
    return "neorg";
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibGliL2NvZGVtaXJyb3IuanMiLCAibW9kZS9zaW1wbGUvc2ltcGxlLmpzIiwgIm1haW4udHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIm1vZHVsZS5leHBvcnRzID0gQ29kZU1pcnJvcjtcblxuIiwgIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lU2ltcGxlTW9kZSA9IGZ1bmN0aW9uKG5hbWUsIHN0YXRlcykge1xuICAgIENvZGVNaXJyb3IuZGVmaW5lTW9kZShuYW1lLCBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHJldHVybiBDb2RlTWlycm9yLnNpbXBsZU1vZGUoY29uZmlnLCBzdGF0ZXMpO1xuICAgIH0pO1xuICB9O1xuXG4gIENvZGVNaXJyb3Iuc2ltcGxlTW9kZSA9IGZ1bmN0aW9uKGNvbmZpZywgc3RhdGVzKSB7XG4gICAgZW5zdXJlU3RhdGUoc3RhdGVzLCBcInN0YXJ0XCIpO1xuICAgIHZhciBzdGF0ZXNfID0ge30sIG1ldGEgPSBzdGF0ZXMubWV0YSB8fCB7fSwgaGFzSW5kZW50YXRpb24gPSBmYWxzZTtcbiAgICBmb3IgKHZhciBzdGF0ZSBpbiBzdGF0ZXMpIGlmIChzdGF0ZSAhPSBtZXRhICYmIHN0YXRlcy5oYXNPd25Qcm9wZXJ0eShzdGF0ZSkpIHtcbiAgICAgIHZhciBsaXN0ID0gc3RhdGVzX1tzdGF0ZV0gPSBbXSwgb3JpZyA9IHN0YXRlc1tzdGF0ZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yaWcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGRhdGEgPSBvcmlnW2ldO1xuICAgICAgICBsaXN0LnB1c2gobmV3IFJ1bGUoZGF0YSwgc3RhdGVzKSk7XG4gICAgICAgIGlmIChkYXRhLmluZGVudCB8fCBkYXRhLmRlZGVudCkgaGFzSW5kZW50YXRpb24gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbW9kZSA9IHtcbiAgICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge3N0YXRlOiBcInN0YXJ0XCIsIHBlbmRpbmc6IG51bGwsXG4gICAgICAgICAgICAgICAgbG9jYWw6IG51bGwsIGxvY2FsU3RhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgaW5kZW50OiBoYXNJbmRlbnRhdGlvbiA/IFtdIDogbnVsbH07XG4gICAgICB9LFxuICAgICAgY29weVN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICB2YXIgcyA9IHtzdGF0ZTogc3RhdGUuc3RhdGUsIHBlbmRpbmc6IHN0YXRlLnBlbmRpbmcsXG4gICAgICAgICAgICAgICAgIGxvY2FsOiBzdGF0ZS5sb2NhbCwgbG9jYWxTdGF0ZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgaW5kZW50OiBzdGF0ZS5pbmRlbnQgJiYgc3RhdGUuaW5kZW50LnNsaWNlKDApfTtcbiAgICAgICAgaWYgKHN0YXRlLmxvY2FsU3RhdGUpXG4gICAgICAgICAgcy5sb2NhbFN0YXRlID0gQ29kZU1pcnJvci5jb3B5U3RhdGUoc3RhdGUubG9jYWwubW9kZSwgc3RhdGUubG9jYWxTdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5zdGFjaylcbiAgICAgICAgICBzLnN0YWNrID0gc3RhdGUuc3RhY2suc2xpY2UoMCk7XG4gICAgICAgIGZvciAodmFyIHBlcnMgPSBzdGF0ZS5wZXJzaXN0ZW50U3RhdGVzOyBwZXJzOyBwZXJzID0gcGVycy5uZXh0KVxuICAgICAgICAgIHMucGVyc2lzdGVudFN0YXRlcyA9IHttb2RlOiBwZXJzLm1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWM6IHBlcnMuc3BlYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHBlcnMuc3RhdGUgPT0gc3RhdGUubG9jYWxTdGF0ZSA/IHMubG9jYWxTdGF0ZSA6IENvZGVNaXJyb3IuY29weVN0YXRlKHBlcnMubW9kZSwgcGVycy5zdGF0ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQ6IHMucGVyc2lzdGVudFN0YXRlc307XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfSxcbiAgICAgIHRva2VuOiB0b2tlbkZ1bmN0aW9uKHN0YXRlc18sIGNvbmZpZyksXG4gICAgICBpbm5lck1vZGU6IGZ1bmN0aW9uKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5sb2NhbCAmJiB7bW9kZTogc3RhdGUubG9jYWwubW9kZSwgc3RhdGU6IHN0YXRlLmxvY2FsU3RhdGV9OyB9LFxuICAgICAgaW5kZW50OiBpbmRlbnRGdW5jdGlvbihzdGF0ZXNfLCBtZXRhKVxuICAgIH07XG4gICAgaWYgKG1ldGEpIGZvciAodmFyIHByb3AgaW4gbWV0YSkgaWYgKG1ldGEuaGFzT3duUHJvcGVydHkocHJvcCkpXG4gICAgICBtb2RlW3Byb3BdID0gbWV0YVtwcm9wXTtcbiAgICByZXR1cm4gbW9kZTtcbiAgfTtcblxuICBmdW5jdGlvbiBlbnN1cmVTdGF0ZShzdGF0ZXMsIG5hbWUpIHtcbiAgICBpZiAoIXN0YXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZGVmaW5lZCBzdGF0ZSBcIiArIG5hbWUgKyBcIiBpbiBzaW1wbGUgbW9kZVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvUmVnZXgodmFsLCBjYXJldCkge1xuICAgIGlmICghdmFsKSByZXR1cm4gLyg/OikvO1xuICAgIHZhciBmbGFncyA9IFwiXCI7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgaWYgKHZhbC5pZ25vcmVDYXNlKSBmbGFncyA9IFwiaVwiO1xuICAgICAgaWYgKHZhbC51bmljb2RlKSBmbGFncyArPSBcInVcIlxuICAgICAgdmFsID0gdmFsLnNvdXJjZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gU3RyaW5nKHZhbCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVnRXhwKChjYXJldCA9PT0gZmFsc2UgPyBcIlwiIDogXCJeXCIpICsgXCIoPzpcIiArIHZhbCArIFwiKVwiLCBmbGFncyk7XG4gIH1cblxuICBmdW5jdGlvbiBhc1Rva2VuKHZhbCkge1xuICAgIGlmICghdmFsKSByZXR1cm4gbnVsbDtcbiAgICBpZiAodmFsLmFwcGx5KSByZXR1cm4gdmFsXG4gICAgaWYgKHR5cGVvZiB2YWwgPT0gXCJzdHJpbmdcIikgcmV0dXJuIHZhbC5yZXBsYWNlKC9cXC4vZywgXCIgXCIpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKylcbiAgICAgIHJlc3VsdC5wdXNoKHZhbFtpXSAmJiB2YWxbaV0ucmVwbGFjZSgvXFwuL2csIFwiIFwiKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIFJ1bGUoZGF0YSwgc3RhdGVzKSB7XG4gICAgaWYgKGRhdGEubmV4dCB8fCBkYXRhLnB1c2gpIGVuc3VyZVN0YXRlKHN0YXRlcywgZGF0YS5uZXh0IHx8IGRhdGEucHVzaCk7XG4gICAgdGhpcy5yZWdleCA9IHRvUmVnZXgoZGF0YS5yZWdleCk7XG4gICAgdGhpcy50b2tlbiA9IGFzVG9rZW4oZGF0YS50b2tlbik7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuRnVuY3Rpb24oc3RhdGVzLCBjb25maWcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0YXRlLnBlbmRpbmcpIHtcbiAgICAgICAgdmFyIHBlbmQgPSBzdGF0ZS5wZW5kaW5nLnNoaWZ0KCk7XG4gICAgICAgIGlmIChzdGF0ZS5wZW5kaW5nLmxlbmd0aCA9PSAwKSBzdGF0ZS5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgc3RyZWFtLnBvcyArPSBwZW5kLnRleHQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gcGVuZC50b2tlbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLmxvY2FsKSB7XG4gICAgICAgIGlmIChzdGF0ZS5sb2NhbC5lbmQgJiYgc3RyZWFtLm1hdGNoKHN0YXRlLmxvY2FsLmVuZCkpIHtcbiAgICAgICAgICB2YXIgdG9rID0gc3RhdGUubG9jYWwuZW5kVG9rZW4gfHwgbnVsbDtcbiAgICAgICAgICBzdGF0ZS5sb2NhbCA9IHN0YXRlLmxvY2FsU3RhdGUgPSBudWxsO1xuICAgICAgICAgIHJldHVybiB0b2s7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHRvayA9IHN0YXRlLmxvY2FsLm1vZGUudG9rZW4oc3RyZWFtLCBzdGF0ZS5sb2NhbFN0YXRlKSwgbTtcbiAgICAgICAgICBpZiAoc3RhdGUubG9jYWwuZW5kU2NhbiAmJiAobSA9IHN0YXRlLmxvY2FsLmVuZFNjYW4uZXhlYyhzdHJlYW0uY3VycmVudCgpKSkpXG4gICAgICAgICAgICBzdHJlYW0ucG9zID0gc3RyZWFtLnN0YXJ0ICsgbS5pbmRleDtcbiAgICAgICAgICByZXR1cm4gdG9rO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJTdGF0ZSA9IHN0YXRlc1tzdGF0ZS5zdGF0ZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1clN0YXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBydWxlID0gY3VyU3RhdGVbaV07XG4gICAgICAgIHZhciBtYXRjaGVzID0gKCFydWxlLmRhdGEuc29sIHx8IHN0cmVhbS5zb2woKSkgJiYgc3RyZWFtLm1hdGNoKHJ1bGUucmVnZXgpO1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgIGlmIChydWxlLmRhdGEubmV4dCkge1xuICAgICAgICAgICAgc3RhdGUuc3RhdGUgPSBydWxlLmRhdGEubmV4dDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJ1bGUuZGF0YS5wdXNoKSB7XG4gICAgICAgICAgICAoc3RhdGUuc3RhY2sgfHwgKHN0YXRlLnN0YWNrID0gW10pKS5wdXNoKHN0YXRlLnN0YXRlKTtcbiAgICAgICAgICAgIHN0YXRlLnN0YXRlID0gcnVsZS5kYXRhLnB1c2g7XG4gICAgICAgICAgfSBlbHNlIGlmIChydWxlLmRhdGEucG9wICYmIHN0YXRlLnN0YWNrICYmIHN0YXRlLnN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgc3RhdGUuc3RhdGUgPSBzdGF0ZS5zdGFjay5wb3AoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocnVsZS5kYXRhLm1vZGUpXG4gICAgICAgICAgICBlbnRlckxvY2FsTW9kZShjb25maWcsIHN0YXRlLCBydWxlLmRhdGEubW9kZSwgcnVsZS50b2tlbik7XG4gICAgICAgICAgaWYgKHJ1bGUuZGF0YS5pbmRlbnQpXG4gICAgICAgICAgICBzdGF0ZS5pbmRlbnQucHVzaChzdHJlYW0uaW5kZW50YXRpb24oKSArIGNvbmZpZy5pbmRlbnRVbml0KTtcbiAgICAgICAgICBpZiAocnVsZS5kYXRhLmRlZGVudClcbiAgICAgICAgICAgIHN0YXRlLmluZGVudC5wb3AoKTtcbiAgICAgICAgICB2YXIgdG9rZW4gPSBydWxlLnRva2VuXG4gICAgICAgICAgaWYgKHRva2VuICYmIHRva2VuLmFwcGx5KSB0b2tlbiA9IHRva2VuKG1hdGNoZXMpXG4gICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMiAmJiBydWxlLnRva2VuICYmIHR5cGVvZiBydWxlLnRva2VuICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAyOyBqIDwgbWF0Y2hlcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgaWYgKG1hdGNoZXNbal0pXG4gICAgICAgICAgICAgICAgKHN0YXRlLnBlbmRpbmcgfHwgKHN0YXRlLnBlbmRpbmcgPSBbXSkpLnB1c2goe3RleHQ6IG1hdGNoZXNbal0sIHRva2VuOiBydWxlLnRva2VuW2ogLSAxXX0pO1xuICAgICAgICAgICAgc3RyZWFtLmJhY2tVcChtYXRjaGVzWzBdLmxlbmd0aCAtIChtYXRjaGVzWzFdID8gbWF0Y2hlc1sxXS5sZW5ndGggOiAwKSk7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5bMF07XG4gICAgICAgICAgfSBlbHNlIGlmICh0b2tlbiAmJiB0b2tlbi5qb2luKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5bMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY21wKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFhIHx8IHR5cGVvZiBhICE9IFwib2JqZWN0XCIgfHwgIWIgfHwgdHlwZW9mIGIgIT0gXCJvYmplY3RcIikgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBwcm9wcyA9IDA7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBhKSBpZiAoYS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgaWYgKCFiLmhhc093blByb3BlcnR5KHByb3ApIHx8ICFjbXAoYVtwcm9wXSwgYltwcm9wXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHByb3BzKys7XG4gICAgfVxuICAgIGZvciAodmFyIHByb3AgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocHJvcCkpIHByb3BzLS07XG4gICAgcmV0dXJuIHByb3BzID09IDA7XG4gIH1cblxuICBmdW5jdGlvbiBlbnRlckxvY2FsTW9kZShjb25maWcsIHN0YXRlLCBzcGVjLCB0b2tlbikge1xuICAgIHZhciBwZXJzO1xuICAgIGlmIChzcGVjLnBlcnNpc3RlbnQpIGZvciAodmFyIHAgPSBzdGF0ZS5wZXJzaXN0ZW50U3RhdGVzOyBwICYmICFwZXJzOyBwID0gcC5uZXh0KVxuICAgICAgaWYgKHNwZWMuc3BlYyA/IGNtcChzcGVjLnNwZWMsIHAuc3BlYykgOiBzcGVjLm1vZGUgPT0gcC5tb2RlKSBwZXJzID0gcDtcbiAgICB2YXIgbW9kZSA9IHBlcnMgPyBwZXJzLm1vZGUgOiBzcGVjLm1vZGUgfHwgQ29kZU1pcnJvci5nZXRNb2RlKGNvbmZpZywgc3BlYy5zcGVjKTtcbiAgICB2YXIgbFN0YXRlID0gcGVycyA/IHBlcnMuc3RhdGUgOiBDb2RlTWlycm9yLnN0YXJ0U3RhdGUobW9kZSk7XG4gICAgaWYgKHNwZWMucGVyc2lzdGVudCAmJiAhcGVycylcbiAgICAgIHN0YXRlLnBlcnNpc3RlbnRTdGF0ZXMgPSB7bW9kZTogbW9kZSwgc3BlYzogc3BlYy5zcGVjLCBzdGF0ZTogbFN0YXRlLCBuZXh0OiBzdGF0ZS5wZXJzaXN0ZW50U3RhdGVzfTtcblxuICAgIHN0YXRlLmxvY2FsU3RhdGUgPSBsU3RhdGU7XG4gICAgc3RhdGUubG9jYWwgPSB7bW9kZTogbW9kZSxcbiAgICAgICAgICAgICAgICAgICBlbmQ6IHNwZWMuZW5kICYmIHRvUmVnZXgoc3BlYy5lbmQpLFxuICAgICAgICAgICAgICAgICAgIGVuZFNjYW46IHNwZWMuZW5kICYmIHNwZWMuZm9yY2VFbmQgIT09IGZhbHNlICYmIHRvUmVnZXgoc3BlYy5lbmQsIGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICBlbmRUb2tlbjogdG9rZW4gJiYgdG9rZW4uam9pbiA/IHRva2VuW3Rva2VuLmxlbmd0aCAtIDFdIDogdG9rZW59O1xuICB9XG5cbiAgZnVuY3Rpb24gaW5kZXhPZih2YWwsIGFycikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBpZiAoYXJyW2ldID09PSB2YWwpIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5kZW50RnVuY3Rpb24oc3RhdGVzLCBtZXRhKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIsIGxpbmUpIHtcbiAgICAgIGlmIChzdGF0ZS5sb2NhbCAmJiBzdGF0ZS5sb2NhbC5tb2RlLmluZGVudClcbiAgICAgICAgcmV0dXJuIHN0YXRlLmxvY2FsLm1vZGUuaW5kZW50KHN0YXRlLmxvY2FsU3RhdGUsIHRleHRBZnRlciwgbGluZSk7XG4gICAgICBpZiAoc3RhdGUuaW5kZW50ID09IG51bGwgfHwgc3RhdGUubG9jYWwgfHwgbWV0YS5kb250SW5kZW50U3RhdGVzICYmIGluZGV4T2Yoc3RhdGUuc3RhdGUsIG1ldGEuZG9udEluZGVudFN0YXRlcykgPiAtMSlcbiAgICAgICAgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcblxuICAgICAgdmFyIHBvcyA9IHN0YXRlLmluZGVudC5sZW5ndGggLSAxLCBydWxlcyA9IHN0YXRlc1tzdGF0ZS5zdGF0ZV07XG4gICAgICBzY2FuOiBmb3IgKDs7KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcnVsZSA9IHJ1bGVzW2ldO1xuICAgICAgICAgIGlmIChydWxlLmRhdGEuZGVkZW50ICYmIHJ1bGUuZGF0YS5kZWRlbnRJZkxpbmVTdGFydCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhciBtID0gcnVsZS5yZWdleC5leGVjKHRleHRBZnRlcik7XG4gICAgICAgICAgICBpZiAobSAmJiBtWzBdKSB7XG4gICAgICAgICAgICAgIHBvcy0tO1xuICAgICAgICAgICAgICBpZiAocnVsZS5uZXh0IHx8IHJ1bGUucHVzaCkgcnVsZXMgPSBzdGF0ZXNbcnVsZS5uZXh0IHx8IHJ1bGUucHVzaF07XG4gICAgICAgICAgICAgIHRleHRBZnRlciA9IHRleHRBZnRlci5zbGljZShtWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIHNjYW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvcyA8IDAgPyAwIDogc3RhdGUuaW5kZW50W3Bvc107XG4gICAgfTtcbiAgfVxufSk7XG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBUZXh0RmlsZVZpZXcsIFdvcmtzcGFjZUxlYWYsIE1hcmtkb3duVmlldyB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IFwiLi9zcmMvbm9yZy1wYXJzZS5qc1wiO1xuaW1wb3J0IFwiLi9saWIvY29kZW1pcnJvci5qc1wiO1xuaW1wb3J0IFwiLi9tb2RlL3NpbXBsZS9zaW1wbGUuanNcIjtcbi8vaW1wb3J0IFwiLi90cmVlLXNpdHRlci1ub3JnLW1haW4vYmluZGluZ3Mvbm9kZS9pbmRleC5qc1wiO1xuXG5pbXBvcnQge1xuICAgIFdpZGdldFR5cGUsXG4gICAgRGVjb3JhdGlvblNldFxufSBmcm9tIFwiQGNvZGVtaXJyb3Ivdmlld1wiO1xuXG5pbXBvcnQgQ29kZU1pcnJvciBmcm9tIFwiLi9saWIvY29kZW1pcnJvci5qc1wiO1xuXG5Db2RlTWlycm9yLmRlZmluZVNpbXBsZU1vZGUoXCJuZW9yZ1wiLCB7XG4gICAgc3RhcnQ6IFtcbiAgICAgICAgeyByZWdleDogL15cXCogLiokLywgdG9rZW46IFtcImhlYWRlci0xXCIsIFwiaGVhZGVyXCJdLCBzb2w6IHRydWUgfSxcbiAgICAgICAgeyByZWdleDogL15cXCpcXCogLiovLCB0b2tlbjogW1wiaGVhZGVyLTJcIiwgXCJoZWFkZXJcIl0sIHNvbDogdHJ1ZSB9LFxuICAgICAgICB7IHJlZ2V4OiAvXlxcKlxcKlxcKiAuKi8sIHRva2VuOiBbXCJoZWFkZXItM1wiLCBcImhlYWRlclwiXSwgc29sOiB0cnVlIH0sXG4gICAgICAgIHsgcmVnZXg6IC9eXFwqXFwqXFwqXFwqIC4qLywgdG9rZW46IFtcImhlYWRlci00XCIsIFwiaGVhZGVyXCJdLCBzb2w6IHRydWUgfSxcblxuICAgICAgICB7IHJlZ2V4OiAvXlxccypcXH4uKiQvLCB0b2tlbjogW1wibGlzdC1pdGVtXCJdLCBzb2w6IHRydWUgfSxcblxuICAgICAgICB7IHJlZ2V4OiBcIlxcLyguKj8pXFwvXCIsIHRva2VuOiBbXCJpdGFsaWNcIl0gfSxcbiAgICAgICAgeyByZWdleDogL1xcKiguKj8pXFwqLywgdG9rZW46IFtcImJvbGRcIl0gfSxcbiAgICAgICAgeyByZWdleDogL2AoW15gXSspYC8sIHRva2VuOiBbXCJpbmxpbmUtY29kZVwiXSB9LFxuXG4gICAgICAgIHsgcmVnZXg6IC9eXFxzKi0gXFwoIFxcKS8sIHRva2VuOiBbXCJ0YXNrIHRvZG9cIl0sIHNvbDogdHJ1ZSB9LFxuICAgICAgICB7IHJlZ2V4OiAvXlxccyotIFxcKC1cXCkvLCB0b2tlbjogW1widGFzayBwZW5kaW5nXCJdLCBzb2w6IHRydWUgfSxcbiAgICAgICAgeyByZWdleDogL15cXHMqLSBcXCh4XFwpLywgdG9rZW46IFtcInRhc2sgZG9uZVwiXSwgc29sOiB0cnVlIH0sXG5cbiAgICBdLFxuXG4gICAgZW52OiBbXG4gICAgICAgIHsgcmVnZXg6IC9cXCNcXCsoPzooRU5EfGVuZCkpX1thLXpBLVpdKi8sIHRva2VuOiBcImNvbW1lbnRcIiwgbmV4dDogXCJzdGFydFwiLCBzb2w6IHRydWUgfSxcbiAgICAgICAgeyByZWdleDogLy4qLywgdG9rZW46IFwiY29tbWVudFwiIH1cbiAgICBdXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmVvcmcgZXh0ZW5kcyBQbHVnaW4ge1xuICAgIGFzeW5jIG9ubG9hZCgpIHtcbiAgICAgICAgc3VwZXIub25sb2FkKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGluZyBOZW9yZyBwbHVnaW4gLi4uXCIpO1xuXG4gICAgICAgIHRoaXMucmVnaXN0ZXJWaWV3KFwibmVvcmdcIiwgdGhpcy5uZW9yZ1ZpZXdDcmVhdG9yKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckV4dGVuc2lvbnMoW1wibm9yZ1wiXSwgXCJuZW9yZ1wiKTtcblxuICAgICAgICB0aGlzLmFkZFJpYmJvbkljb24oXCJwbHVzXCIsIFwiTmV3IG5vcmcgZmlsZVwiLCAoKSA9PiB7XG5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmV3TmVvcmdGaWxlKCkge1xuICAgICAgICB0aGlzLmFwcC52YXVsdC5jcmVhdGUoXCJ1bnRpdGxlZDIubm9yZ1wiLCBcIlwiKS50aGVuKGZpbGUgPT4gdGhpcy5hcHAud29ya3NwYWNlLmdldE1vc3RSZWNlbnRMZWFmKCk/Lm9wZW5GaWxlKGZpbGUpKTtcbiAgICB9XG5cbiAgICBuZW9yZ1ZpZXdDcmVhdG9yID0gKGxlYWY6IFdvcmtzcGFjZUxlYWYpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBOZW9yZ1ZpZXcobGVhZik7XG4gICAgfTtcblxuICAgIG9udW5sb2FkKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlVubG9hZGluZyBOZW9yZyBwbHVnaW4gLi4uXCIpO1xuICAgIH1cbn1cblxuY2xhc3MgTmVvcmdWaWV3IGV4dGVuZHMgVGV4dEZpbGVWaWV3IHtcbiAgICAvLyBJbnRlcm5hbCBjb2RlIG1pcnJvciBpbnN0YW5jZTpcbiAgICBjb2RlTWlycm9yOiBDb2RlTWlycm9yLkVkaXRvcjtcbiAgICBkZWNvcmF0aW9uczogRGVjb3JhdGlvblNldDtcblxuICAgIC8vIHRoaXMuY29udGVudEVsIGlzIG5vdCBleHBvc2VkLCBzbyBjaGVhdCBhIGJpdC5cbiAgICBwdWJsaWMgZ2V0IGV4dENvbnRlbnRFbCgpOiBIVE1MRWxlbWVudCB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudEVsO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKGxlYWY6IFdvcmtzcGFjZUxlYWYpIHtcbiAgICAgICAgc3VwZXIobGVhZik7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yID0gQ29kZU1pcnJvcih0aGlzLmV4dENvbnRlbnRFbCwge1xuICAgICAgICAgICAgc2hvd0N1cnNvcldoZW5TZWxlY3Rpbmc6IHRydWUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5vbihcImNoYW5nZXNcIiwgdGhpcy5jaGFuZ2VkKTtcblxuICAgICAgICAvL3RoaXMuY29kZU1pcnJvci5zZXRDdXJzb3IoMCwgMCk7XG4gICAgfVxuXG4gICAgLy8gV2hlbiB0aGUgdmlldyBpcyByZXNpemVkLCByZWZyZXNoIENvZGVNaXJyb3IgKHRoYW5rcyBMaWNhdCEpLlxuICAgIG9uUmVzaXplKCkge1xuICAgICAgICB0aGlzLmNvZGVNaXJyb3IucmVmcmVzaCgpO1xuICAgICAgICB0aGlzLnJlbG9hZEJ1dHRvbnMoKTtcbiAgICB9XG5cbiAgICBjaGFuZ2VkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0aGlzLnJlcXVlc3RTYXZlKCk7XG4gICAgICAgIHRoaXMucmVsb2FkQnV0dG9ucygpO1xuICAgIH07XG5cbiAgICBnZXRWaWV3RGF0YSA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZU1pcnJvci5nZXRWYWx1ZSgpO1xuICAgIH07XG5cbiAgICBzZXRWaWV3RGF0YSA9IChkYXRhOiBzdHJpbmcsIGNsZWFyOiBib29sZWFuKSA9PiB7XG4gICAgICAgIGlmIChjbGVhcikge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnN3YXBEb2MoQ29kZU1pcnJvci5Eb2MoZGF0YSwgXCJuZW9yZ1wiKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0VmFsdWUoZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIC8vaWYgKHRoaXMuYXBwPy52YXVsdD8uY29uZmlnPy52aW1Nb2RlKSB7XG4gICAgICAgIC8vICB0aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwia2V5TWFwXCIsIFwidmltXCIpO1xuICAgICAgICAvL31cblxuICAgICAgICAvLyBUaGlzIHNlZW1zIHRvIGZpeCBzb21lIG9kZCB2aXN1YWwgYnVnczpcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLnJlZnJlc2goKTtcblxuICAgICAgICAvLyBUaGlzIGZvY3VzZXMgdGhlIGVkaXRvciwgd2hpY2ggaXMgYW5hbG9nb3VzIHRvIHRoZVxuICAgICAgICAvLyBkZWZhdWx0IE1hcmtkb3duIGJlaGF2aW9yIGluIE9ic2lkaWFuOlxuICAgICAgICB0aGlzLmNvZGVNaXJyb3IuZm9jdXMoKTtcblxuICAgICAgICB0aGlzLnJlbG9hZEJ1dHRvbnMoKTtcbiAgICB9O1xuXG4gICAgcmVsb2FkQnV0dG9ucyAoKSB7XG4gICAgICAgIGNvbnN0IHRvZG9FbGVtZW50cyA9IHRoaXMuY29udGVudEVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy50YXNrJyk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGVhY2ggJ3RvZG8nIGVsZW1lbnRcbiAgICAgICAgdG9kb0VsZW1lbnRzLmZvckVhY2godG9kb0VsZW1lbnQgPT4ge1xuICAgICAgICAgICAgdG9kb0VsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5jb2RlTWlycm9yLmdldFdyYXBwZXJFbGVtZW50KCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciB0b3BWaXNpYmxlTGluZSA9IHRoaXMuY29kZU1pcnJvci5saW5lQXRIZWlnaHQocmVjdC50b3AsIFwid2luZG93XCIpO1xuICAgICAgICB2YXIgYm90dG9tVmlzaWJsZUxpbmUgPSB0aGlzLmNvZGVNaXJyb3IubGluZUF0SGVpZ2h0KHJlY3QuYm90dG9tLCBcIndpbmRvd1wiKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gdG9wVmlzaWJsZUxpbmU7IGkgPCBib3R0b21WaXNpYmxlTGluZTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdG9rZW5zID0gdGhpcy5jb2RlTWlycm9yLmdldExpbmVUb2tlbnMoaSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRva2Vucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbnNbal0udHlwZT8uc3RhcnRzV2l0aChcInRhc2tcIikpIHsgdGhpcy50b2RvQnV0dG9uKHRva2Vuc1tqXSwgaSk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBcbiAgICB9XG5cbiAgICB0b2RvQnV0dG9uKHRva2VuLCBsaW5lKSB7XG4gICAgICAgIGxldCBsaW5lcyA9IHRoaXMuY29udGVudEVsLnF1ZXJ5U2VsZWN0b3IoXCIuQ29kZU1pcnJvci1saW5lc1wiKTtcblxuICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICAgIGxldCBidXR0b24gPSBsaW5lcy5jcmVhdGVFbChcImlucHV0XCIpO1xuICAgICAgICAgICAgYnV0dG9uLnR5cGUgPSBcImNoZWNrYm94XCI7XG4gICAgICAgICAgICBidXR0b24uY2xhc3NOYW1lID0gdG9rZW4udHlwZTtcbiAgICAgICAgICAgIGNvbnN0IGNvb3JkcyA9IHRoaXMuY29kZU1pcnJvci5jaGFyQ29vcmRzKHsgbGluZTogbGluZSwgY2g6IHRva2VuLnN0YXJ0IH0sICdsb2NhbCcpO1xuICAgICAgICAgICAgYnV0dG9uLnN0eWxlLmxlZnQgPSBjb29yZHMubGVmdC50b1N0cmluZygpICsgXCJweFwiO1xuICAgICAgICAgICAgYnV0dG9uLnN0eWxlLnRvcCA9IGNvb3Jkcy50b3AudG9TdHJpbmcoKSArIFwicHhcIjtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRva2VuLnR5cGUpO1xuICAgICAgICAgICAgYnV0dG9uLmNoZWNrZWQgPSB0b2tlbi50eXBlID09IFwidGFzayBkb25lXCI7IFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgY20gPSB0aGlzLmNvZGVNaXJyb3I7XG4gICAgICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RleHQgPSBidXR0b24uY2hlY2tlZCA/ICctICh4KScgOiAnLSAoICknO1xuICAgICAgICAgICAgICAgIHRoaXMuY29kZU1pcnJvci5yZXBsYWNlUmFuZ2UobmV3VGV4dCwgeyBsaW5lOiBsaW5lLCBjaDogdG9rZW4uc3RhcnQgfSwgeyBsaW5lOiBsaW5lLCBjaDogdG9rZW4uZW5kIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGVhciA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldFZhbHVlKFwiXCIpO1xuICAgICAgICB0aGlzLmNvZGVNaXJyb3IuY2xlYXJIaXN0b3J5KCk7XG4gICAgfTtcblxuICAgIGdldERpc3BsYXlUZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5maWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlLmJhc2VuYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwib3JnIChObyBGaWxlKVwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2FuQWNjZXB0RXh0ZW5zaW9uKGV4dGVuc2lvbjogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBleHRlbnNpb24gPT09IFwibm9yZ1wiO1xuICAgIH1cblxuICAgIGdldFZpZXdUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJuZW9yZ1wiO1xuICAgIH1cbn1cblxuY2xhc3MgQ2hlY2tib3hXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihyZWFkb25seSBjaGVja2VkOiBib29sZWFuKSB7IHN1cGVyKCkgfVxuXG4gICAgZXEob3RoZXI6IENoZWNrYm94V2lkZ2V0KSB7IHJldHVybiBvdGhlci5jaGVja2VkID09IHRoaXMuY2hlY2tlZCB9XG5cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IHdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKVxuICAgICAgICB3cmFwLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKVxuICAgICAgICB3cmFwLmNsYXNzTmFtZSA9IFwiY20tYm9vbGVhbi10b2dnbGVcIlxuICAgICAgICBsZXQgYm94ID0gd3JhcC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIikpXG4gICAgICAgIGJveC50eXBlID0gXCJjaGVja2JveFwiXG4gICAgICAgIGJveC5jaGVja2VkID0gdGhpcy5jaGVja2VkXG4gICAgICAgIHJldHVybiB3cmFwXG4gICAgfVxuXG4gICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZSB9XG59XG5cbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBLCtCQUFBQSxTQUFBO0FBQUEsSUFBQUEsUUFBTyxVQUFVO0FBQUE7QUFBQTs7O0FDQWpCO0FBQUEsbUNBQUFDLFNBQUE7QUFHQSxLQUFDLFNBQVMsS0FBSztBQUNiLFVBQUksT0FBTyxXQUFXLFlBQVksT0FBT0EsV0FBVTtBQUNqRCxZQUFJLG9CQUErQjtBQUFBLGVBQzVCLE9BQU8sVUFBVSxjQUFjLE9BQU87QUFDN0MsZUFBTyxDQUFDLHNCQUFzQixHQUFHLEdBQUc7QUFBQTtBQUVwQyxZQUFJLFVBQVU7QUFBQSxJQUNsQixHQUFHLFNBQVNDLGFBQVk7QUFDdEI7QUFF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QWU7QUFDaEMsa0JBQVksT0FBTztBQUFBLElBQ3ZCLENBQUM7QUFFRCxRQUFJLE9BQU8sS0FBSyxXQUFXLGtCQUFrQixFQUFFLHNCQUFzQjtBQUNyRSxRQUFJLGlCQUFpQixLQUFLLFdBQVcsYUFBYSxLQUFLLEtBQUssUUFBUTtBQUNwRSxRQUFJLG9CQUFvQixLQUFLLFdBQVcsYUFBYSxLQUFLLFFBQVEsUUFBUTtBQUUxRSxhQUFTLElBQUksZ0JBQWdCLElBQUksbUJBQW1CLEtBQUs7QUFDckQsVUFBSSxTQUFTLEtBQUssV0FBVyxjQUFjLENBQUM7QUFDNUMsZUFBUyxJQUFJLEdBQUcsSUFBSSxPQUFPLFFBQVEsS0FBSztBQUNwQyxhQUFJLFlBQU8sQ0FBQyxFQUFFLFNBQVYsbUJBQWdCLFdBQVcsU0FBUztBQUFFLGVBQUssV0FBVyxPQUFPLENBQUMsR0FBRyxDQUFDO0FBQUEsUUFBRztBQUFBLE1BQzdFO0FBQUEsSUFDSjtBQUFBLEVBQ0o7QUFBQSxFQUVBLFdBQVcsT0FBTyxNQUFNO0FBQ3BCLFFBQUksUUFBUSxLQUFLLFVBQVUsY0FBYyxtQkFBbUI7QUFFNUQsUUFBSSxPQUFPO0FBQ1AsVUFBSSxTQUFTLE1BQU0sU0FBUyxPQUFPO0FBQ25DLGFBQU8sT0FBTztBQUNkLGFBQU8sWUFBWSxNQUFNO0FBQ3pCLFlBQU0sU0FBUyxLQUFLLFdBQVcsV0FBVyxFQUFFLE1BQVksSUFBSSxNQUFNLE1BQU0sR0FBRyxPQUFPO0FBQ2xGLGFBQU8sTUFBTSxPQUFPLE9BQU8sS0FBSyxTQUFTLElBQUk7QUFDN0MsYUFBTyxNQUFNLE1BQU0sT0FBTyxJQUFJLFNBQVMsSUFBSTtBQUMzQyxjQUFRLElBQUksTUFBTSxJQUFJO0FBQ3RCLGFBQU8sVUFBVSxNQUFNLFFBQVE7QUFFL0IsVUFBSSxLQUFLLEtBQUs7QUFDZCxhQUFPLGlCQUFpQixVQUFVLE1BQU07QUFDcEMsY0FBTSxVQUFVLE9BQU8sVUFBVSxVQUFVO0FBQzNDLGFBQUssV0FBVyxhQUFhLFNBQVMsRUFBRSxNQUFZLElBQUksTUFBTSxNQUFNLEdBQUcsRUFBRSxNQUFZLElBQUksTUFBTSxJQUFJLENBQUM7QUFBQSxNQUN4RyxDQUFDO0FBQUEsSUFDTDtBQUFBLEVBQ0o7QUFBQSxFQU9BLGlCQUFpQjtBQUNiLFFBQUksS0FBSyxNQUFNO0FBQ1gsYUFBTyxLQUFLLEtBQUs7QUFBQSxJQUNyQixPQUFPO0FBQ0gsYUFBTztBQUFBLElBQ1g7QUFBQSxFQUNKO0FBQUEsRUFFQSxtQkFBbUIsV0FBbUI7QUFDbEMsV0FBTyxjQUFjO0FBQUEsRUFDekI7QUFBQSxFQUVBLGNBQWM7QUFDVixXQUFPO0FBQUEsRUFDWDtBQUNKOyIsCiAgIm5hbWVzIjogWyJtb2R1bGUiLCAibW9kdWxlIiwgIkNvZGVNaXJyb3IiLCAic3RhdGUiLCAiaW1wb3J0X2NvZGVtaXJyb3IiLCAiQ29kZU1pcnJvciJdCn0K
