/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// lib/codemirror.js
var require_codemirror = __commonJS({
  "lib/codemirror.js"(exports, module2) {
    module2.exports = CodeMirror;
  }
});

// mode/simple/simple.js
var require_simple = __commonJS({
  "mode/simple/simple.js"(exports, module2) {
    (function(mod) {
      if (typeof exports == "object" && typeof module2 == "object")
        mod(require_codemirror());
      else if (typeof define == "function" && define.amd)
        define(["../../lib/codemirror"], mod);
      else
        mod(CodeMirror);
    })(function(CodeMirror2) {
      "use strict";
      CodeMirror2.defineSimpleMode = function(name, states) {
        CodeMirror2.defineMode(name, function(config) {
          return CodeMirror2.simpleMode(config, states);
        });
      };
      CodeMirror2.simpleMode = function(config, states) {
        ensureState(states, "start");
        var states_ = {}, meta = states.meta || {}, hasIndentation = false;
        for (var state in states)
          if (state != meta && states.hasOwnProperty(state)) {
            var list = states_[state] = [], orig = states[state];
            for (var i = 0; i < orig.length; i++) {
              var data = orig[i];
              list.push(new Rule(data, states));
              if (data.indent || data.dedent)
                hasIndentation = true;
            }
          }
        var mode = {
          startState: function() {
            return {
              state: "start",
              pending: null,
              local: null,
              localState: null,
              indent: hasIndentation ? [] : null
            };
          },
          copyState: function(state2) {
            var s = {
              state: state2.state,
              pending: state2.pending,
              local: state2.local,
              localState: null,
              indent: state2.indent && state2.indent.slice(0)
            };
            if (state2.localState)
              s.localState = CodeMirror2.copyState(state2.local.mode, state2.localState);
            if (state2.stack)
              s.stack = state2.stack.slice(0);
            for (var pers = state2.persistentStates; pers; pers = pers.next)
              s.persistentStates = {
                mode: pers.mode,
                spec: pers.spec,
                state: pers.state == state2.localState ? s.localState : CodeMirror2.copyState(pers.mode, pers.state),
                next: s.persistentStates
              };
            return s;
          },
          token: tokenFunction(states_, config),
          innerMode: function(state2) {
            return state2.local && { mode: state2.local.mode, state: state2.localState };
          },
          indent: indentFunction(states_, meta)
        };
        if (meta) {
          for (var prop in meta)
            if (meta.hasOwnProperty(prop))
              mode[prop] = meta[prop];
        }
        return mode;
      };
      function ensureState(states, name) {
        if (!states.hasOwnProperty(name))
          throw new Error("Undefined state " + name + " in simple mode");
      }
      function toRegex(val, caret) {
        if (!val)
          return /(?:)/;
        var flags = "";
        if (val instanceof RegExp) {
          if (val.ignoreCase)
            flags = "i";
          if (val.unicode)
            flags += "u";
          val = val.source;
        } else {
          val = String(val);
        }
        return new RegExp((caret === false ? "" : "^") + "(?:" + val + ")", flags);
      }
      function asToken(val) {
        if (!val)
          return null;
        if (val.apply)
          return val;
        if (typeof val == "string")
          return val.replace(/\./g, " ");
        var result = [];
        for (var i = 0; i < val.length; i++)
          result.push(val[i] && val[i].replace(/\./g, " "));
        return result;
      }
      function Rule(data, states) {
        if (data.next || data.push)
          ensureState(states, data.next || data.push);
        this.regex = toRegex(data.regex);
        this.token = asToken(data.token);
        this.data = data;
      }
      function tokenFunction(states, config) {
        return function(stream, state) {
          if (state.pending) {
            var pend = state.pending.shift();
            if (state.pending.length == 0)
              state.pending = null;
            stream.pos += pend.text.length;
            return pend.token;
          }
          if (state.local) {
            if (state.local.end && stream.match(state.local.end)) {
              var tok = state.local.endToken || null;
              state.local = state.localState = null;
              return tok;
            } else {
              var tok = state.local.mode.token(stream, state.localState), m;
              if (state.local.endScan && (m = state.local.endScan.exec(stream.current())))
                stream.pos = stream.start + m.index;
              return tok;
            }
          }
          var curState = states[state.state];
          for (var i = 0; i < curState.length; i++) {
            var rule = curState[i];
            var matches = (!rule.data.sol || stream.sol()) && stream.match(rule.regex);
            if (matches) {
              if (rule.data.next) {
                state.state = rule.data.next;
              } else if (rule.data.push) {
                (state.stack || (state.stack = [])).push(state.state);
                state.state = rule.data.push;
              } else if (rule.data.pop && state.stack && state.stack.length) {
                state.state = state.stack.pop();
              }
              if (rule.data.mode)
                enterLocalMode(config, state, rule.data.mode, rule.token);
              if (rule.data.indent)
                state.indent.push(stream.indentation() + config.indentUnit);
              if (rule.data.dedent)
                state.indent.pop();
              var token = rule.token;
              if (token && token.apply)
                token = token(matches);
              if (matches.length > 2 && rule.token && typeof rule.token != "string") {
                for (var j = 2; j < matches.length; j++)
                  if (matches[j])
                    (state.pending || (state.pending = [])).push({ text: matches[j], token: rule.token[j - 1] });
                stream.backUp(matches[0].length - (matches[1] ? matches[1].length : 0));
                return token[0];
              } else if (token && token.join) {
                return token[0];
              } else {
                return token;
              }
            }
          }
          stream.next();
          return null;
        };
      }
      function cmp(a, b) {
        if (a === b)
          return true;
        if (!a || typeof a != "object" || !b || typeof b != "object")
          return false;
        var props = 0;
        for (var prop in a)
          if (a.hasOwnProperty(prop)) {
            if (!b.hasOwnProperty(prop) || !cmp(a[prop], b[prop]))
              return false;
            props++;
          }
        for (var prop in b)
          if (b.hasOwnProperty(prop))
            props--;
        return props == 0;
      }
      function enterLocalMode(config, state, spec, token) {
        var pers;
        if (spec.persistent) {
          for (var p = state.persistentStates; p && !pers; p = p.next)
            if (spec.spec ? cmp(spec.spec, p.spec) : spec.mode == p.mode)
              pers = p;
        }
        var mode = pers ? pers.mode : spec.mode || CodeMirror2.getMode(config, spec.spec);
        var lState = pers ? pers.state : CodeMirror2.startState(mode);
        if (spec.persistent && !pers)
          state.persistentStates = { mode, spec: spec.spec, state: lState, next: state.persistentStates };
        state.localState = lState;
        state.local = {
          mode,
          end: spec.end && toRegex(spec.end),
          endScan: spec.end && spec.forceEnd !== false && toRegex(spec.end, false),
          endToken: token && token.join ? token[token.length - 1] : token
        };
      }
      function indexOf(val, arr) {
        for (var i = 0; i < arr.length; i++)
          if (arr[i] === val)
            return true;
      }
      function indentFunction(states, meta) {
        return function(state, textAfter, line) {
          if (state.local && state.local.mode.indent)
            return state.local.mode.indent(state.localState, textAfter, line);
          if (state.indent == null || state.local || meta.dontIndentStates && indexOf(state.state, meta.dontIndentStates) > -1)
            return CodeMirror2.Pass;
          var pos = state.indent.length - 1, rules = states[state.state];
          scan:
            for (; ; ) {
              for (var i = 0; i < rules.length; i++) {
                var rule = rules[i];
                if (rule.data.dedent && rule.data.dedentIfLineStart !== false) {
                  var m = rule.regex.exec(textAfter);
                  if (m && m[0]) {
                    pos--;
                    if (rule.next || rule.push)
                      rules = states[rule.next || rule.push];
                    textAfter = textAfter.slice(m[0].length);
                    continue scan;
                  }
                }
              }
              break;
            }
          return pos < 0 ? 0 : state.indent[pos];
        };
      }
    });
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Neorg
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_codemirror = __toESM(require_codemirror());
var import_simple = __toESM(require_simple());
CodeMirror.defineSimpleMode("neorg", {
  start: [
    { regex: /^\* .*$/, token: ["header-1", "header"], sol: true },
    { regex: /^\*\* .*/, token: ["header-2", "header"], sol: true },
    { regex: /^\*\*\* .*/, token: ["header-3", "header"], sol: true },
    { regex: /^\s*\~.*$/, token: ["list-item"], sol: true },
    { regex: "/(.*?)/", token: ["italic"] },
    { regex: /\*(.*?)\*/, token: ["bold"] }
  ],
  env: [
    { regex: /\#\+(?:(END|end))_[a-zA-Z]*/, token: "comment", next: "start", sol: true },
    { regex: /.*/, token: "comment" }
  ]
});
var Neorg = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.neorgViewCreator = (leaf) => {
      return new NeorgView(leaf);
    };
  }
  async onload() {
    super.onload();
    console.log("Loading Neorg plugin ...");
    this.registerView("neorg", this.neorgViewCreator);
    this.registerExtensions(["norg"], "neorg");
  }
  onunload() {
    console.log("Unloading Neorg plugin ...");
  }
};
var NeorgView = class extends import_obsidian.TextFileView {
  constructor(leaf) {
    super(leaf);
    this.changed = async () => {
      this.requestSave();
    };
    this.getViewData = () => {
      return this.codeMirror.getValue();
    };
    this.setViewData = (data, clear) => {
      var _a, _b, _c;
      if (clear) {
        this.codeMirror.swapDoc(CodeMirror.Doc(data, "neorg"));
      } else {
        this.codeMirror.setValue(data);
      }
      if ((_c = (_b = (_a = this.app) == null ? void 0 : _a.vault) == null ? void 0 : _b.config) == null ? void 0 : _c.vimMode) {
        this.codeMirror.setOption("keyMap", "vim");
      }
      this.codeMirror.refresh();
      this.codeMirror.focus();
    };
    this.clear = () => {
      this.codeMirror.setValue("");
      this.codeMirror.clearHistory();
    };
    this.codeMirror = CodeMirror(this.extContentEl, {
      showCursorWhenSelecting: true
    });
    this.codeMirror.on("changes", this.changed);
    this.codeMirror.setCursor(0, 0);
  }
  // this.contentEl is not exposed, so cheat a bit.
  get extContentEl() {
    return this.contentEl;
  }
  // When the view is resized, refresh CodeMirror (thanks Licat!).
  onResize() {
    this.codeMirror.refresh();
  }
  getDisplayText() {
    if (this.file) {
      return this.file.basename;
    } else {
      return "org (No File)";
    }
  }
  canAcceptExtension(extension) {
    return extension === "norg";
  }
  getViewType() {
    return "neorg";
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibGliL2NvZGVtaXJyb3IuanMiLCAibW9kZS9zaW1wbGUvc2ltcGxlLmpzIiwgIm1haW4udHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIm1vZHVsZS5leHBvcnRzID0gQ29kZU1pcnJvcjtcblxuIiwgIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lU2ltcGxlTW9kZSA9IGZ1bmN0aW9uKG5hbWUsIHN0YXRlcykge1xuICAgIENvZGVNaXJyb3IuZGVmaW5lTW9kZShuYW1lLCBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHJldHVybiBDb2RlTWlycm9yLnNpbXBsZU1vZGUoY29uZmlnLCBzdGF0ZXMpO1xuICAgIH0pO1xuICB9O1xuXG4gIENvZGVNaXJyb3Iuc2ltcGxlTW9kZSA9IGZ1bmN0aW9uKGNvbmZpZywgc3RhdGVzKSB7XG4gICAgZW5zdXJlU3RhdGUoc3RhdGVzLCBcInN0YXJ0XCIpO1xuICAgIHZhciBzdGF0ZXNfID0ge30sIG1ldGEgPSBzdGF0ZXMubWV0YSB8fCB7fSwgaGFzSW5kZW50YXRpb24gPSBmYWxzZTtcbiAgICBmb3IgKHZhciBzdGF0ZSBpbiBzdGF0ZXMpIGlmIChzdGF0ZSAhPSBtZXRhICYmIHN0YXRlcy5oYXNPd25Qcm9wZXJ0eShzdGF0ZSkpIHtcbiAgICAgIHZhciBsaXN0ID0gc3RhdGVzX1tzdGF0ZV0gPSBbXSwgb3JpZyA9IHN0YXRlc1tzdGF0ZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yaWcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGRhdGEgPSBvcmlnW2ldO1xuICAgICAgICBsaXN0LnB1c2gobmV3IFJ1bGUoZGF0YSwgc3RhdGVzKSk7XG4gICAgICAgIGlmIChkYXRhLmluZGVudCB8fCBkYXRhLmRlZGVudCkgaGFzSW5kZW50YXRpb24gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbW9kZSA9IHtcbiAgICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge3N0YXRlOiBcInN0YXJ0XCIsIHBlbmRpbmc6IG51bGwsXG4gICAgICAgICAgICAgICAgbG9jYWw6IG51bGwsIGxvY2FsU3RhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgaW5kZW50OiBoYXNJbmRlbnRhdGlvbiA/IFtdIDogbnVsbH07XG4gICAgICB9LFxuICAgICAgY29weVN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICB2YXIgcyA9IHtzdGF0ZTogc3RhdGUuc3RhdGUsIHBlbmRpbmc6IHN0YXRlLnBlbmRpbmcsXG4gICAgICAgICAgICAgICAgIGxvY2FsOiBzdGF0ZS5sb2NhbCwgbG9jYWxTdGF0ZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgaW5kZW50OiBzdGF0ZS5pbmRlbnQgJiYgc3RhdGUuaW5kZW50LnNsaWNlKDApfTtcbiAgICAgICAgaWYgKHN0YXRlLmxvY2FsU3RhdGUpXG4gICAgICAgICAgcy5sb2NhbFN0YXRlID0gQ29kZU1pcnJvci5jb3B5U3RhdGUoc3RhdGUubG9jYWwubW9kZSwgc3RhdGUubG9jYWxTdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5zdGFjaylcbiAgICAgICAgICBzLnN0YWNrID0gc3RhdGUuc3RhY2suc2xpY2UoMCk7XG4gICAgICAgIGZvciAodmFyIHBlcnMgPSBzdGF0ZS5wZXJzaXN0ZW50U3RhdGVzOyBwZXJzOyBwZXJzID0gcGVycy5uZXh0KVxuICAgICAgICAgIHMucGVyc2lzdGVudFN0YXRlcyA9IHttb2RlOiBwZXJzLm1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWM6IHBlcnMuc3BlYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHBlcnMuc3RhdGUgPT0gc3RhdGUubG9jYWxTdGF0ZSA/IHMubG9jYWxTdGF0ZSA6IENvZGVNaXJyb3IuY29weVN0YXRlKHBlcnMubW9kZSwgcGVycy5zdGF0ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQ6IHMucGVyc2lzdGVudFN0YXRlc307XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfSxcbiAgICAgIHRva2VuOiB0b2tlbkZ1bmN0aW9uKHN0YXRlc18sIGNvbmZpZyksXG4gICAgICBpbm5lck1vZGU6IGZ1bmN0aW9uKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5sb2NhbCAmJiB7bW9kZTogc3RhdGUubG9jYWwubW9kZSwgc3RhdGU6IHN0YXRlLmxvY2FsU3RhdGV9OyB9LFxuICAgICAgaW5kZW50OiBpbmRlbnRGdW5jdGlvbihzdGF0ZXNfLCBtZXRhKVxuICAgIH07XG4gICAgaWYgKG1ldGEpIGZvciAodmFyIHByb3AgaW4gbWV0YSkgaWYgKG1ldGEuaGFzT3duUHJvcGVydHkocHJvcCkpXG4gICAgICBtb2RlW3Byb3BdID0gbWV0YVtwcm9wXTtcbiAgICByZXR1cm4gbW9kZTtcbiAgfTtcblxuICBmdW5jdGlvbiBlbnN1cmVTdGF0ZShzdGF0ZXMsIG5hbWUpIHtcbiAgICBpZiAoIXN0YXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZGVmaW5lZCBzdGF0ZSBcIiArIG5hbWUgKyBcIiBpbiBzaW1wbGUgbW9kZVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvUmVnZXgodmFsLCBjYXJldCkge1xuICAgIGlmICghdmFsKSByZXR1cm4gLyg/OikvO1xuICAgIHZhciBmbGFncyA9IFwiXCI7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgaWYgKHZhbC5pZ25vcmVDYXNlKSBmbGFncyA9IFwiaVwiO1xuICAgICAgaWYgKHZhbC51bmljb2RlKSBmbGFncyArPSBcInVcIlxuICAgICAgdmFsID0gdmFsLnNvdXJjZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gU3RyaW5nKHZhbCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVnRXhwKChjYXJldCA9PT0gZmFsc2UgPyBcIlwiIDogXCJeXCIpICsgXCIoPzpcIiArIHZhbCArIFwiKVwiLCBmbGFncyk7XG4gIH1cblxuICBmdW5jdGlvbiBhc1Rva2VuKHZhbCkge1xuICAgIGlmICghdmFsKSByZXR1cm4gbnVsbDtcbiAgICBpZiAodmFsLmFwcGx5KSByZXR1cm4gdmFsXG4gICAgaWYgKHR5cGVvZiB2YWwgPT0gXCJzdHJpbmdcIikgcmV0dXJuIHZhbC5yZXBsYWNlKC9cXC4vZywgXCIgXCIpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKylcbiAgICAgIHJlc3VsdC5wdXNoKHZhbFtpXSAmJiB2YWxbaV0ucmVwbGFjZSgvXFwuL2csIFwiIFwiKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIFJ1bGUoZGF0YSwgc3RhdGVzKSB7XG4gICAgaWYgKGRhdGEubmV4dCB8fCBkYXRhLnB1c2gpIGVuc3VyZVN0YXRlKHN0YXRlcywgZGF0YS5uZXh0IHx8IGRhdGEucHVzaCk7XG4gICAgdGhpcy5yZWdleCA9IHRvUmVnZXgoZGF0YS5yZWdleCk7XG4gICAgdGhpcy50b2tlbiA9IGFzVG9rZW4oZGF0YS50b2tlbik7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuRnVuY3Rpb24oc3RhdGVzLCBjb25maWcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0YXRlLnBlbmRpbmcpIHtcbiAgICAgICAgdmFyIHBlbmQgPSBzdGF0ZS5wZW5kaW5nLnNoaWZ0KCk7XG4gICAgICAgIGlmIChzdGF0ZS5wZW5kaW5nLmxlbmd0aCA9PSAwKSBzdGF0ZS5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgc3RyZWFtLnBvcyArPSBwZW5kLnRleHQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gcGVuZC50b2tlbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLmxvY2FsKSB7XG4gICAgICAgIGlmIChzdGF0ZS5sb2NhbC5lbmQgJiYgc3RyZWFtLm1hdGNoKHN0YXRlLmxvY2FsLmVuZCkpIHtcbiAgICAgICAgICB2YXIgdG9rID0gc3RhdGUubG9jYWwuZW5kVG9rZW4gfHwgbnVsbDtcbiAgICAgICAgICBzdGF0ZS5sb2NhbCA9IHN0YXRlLmxvY2FsU3RhdGUgPSBudWxsO1xuICAgICAgICAgIHJldHVybiB0b2s7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHRvayA9IHN0YXRlLmxvY2FsLm1vZGUudG9rZW4oc3RyZWFtLCBzdGF0ZS5sb2NhbFN0YXRlKSwgbTtcbiAgICAgICAgICBpZiAoc3RhdGUubG9jYWwuZW5kU2NhbiAmJiAobSA9IHN0YXRlLmxvY2FsLmVuZFNjYW4uZXhlYyhzdHJlYW0uY3VycmVudCgpKSkpXG4gICAgICAgICAgICBzdHJlYW0ucG9zID0gc3RyZWFtLnN0YXJ0ICsgbS5pbmRleDtcbiAgICAgICAgICByZXR1cm4gdG9rO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJTdGF0ZSA9IHN0YXRlc1tzdGF0ZS5zdGF0ZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1clN0YXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBydWxlID0gY3VyU3RhdGVbaV07XG4gICAgICAgIHZhciBtYXRjaGVzID0gKCFydWxlLmRhdGEuc29sIHx8IHN0cmVhbS5zb2woKSkgJiYgc3RyZWFtLm1hdGNoKHJ1bGUucmVnZXgpO1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgIGlmIChydWxlLmRhdGEubmV4dCkge1xuICAgICAgICAgICAgc3RhdGUuc3RhdGUgPSBydWxlLmRhdGEubmV4dDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJ1bGUuZGF0YS5wdXNoKSB7XG4gICAgICAgICAgICAoc3RhdGUuc3RhY2sgfHwgKHN0YXRlLnN0YWNrID0gW10pKS5wdXNoKHN0YXRlLnN0YXRlKTtcbiAgICAgICAgICAgIHN0YXRlLnN0YXRlID0gcnVsZS5kYXRhLnB1c2g7XG4gICAgICAgICAgfSBlbHNlIGlmIChydWxlLmRhdGEucG9wICYmIHN0YXRlLnN0YWNrICYmIHN0YXRlLnN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgc3RhdGUuc3RhdGUgPSBzdGF0ZS5zdGFjay5wb3AoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocnVsZS5kYXRhLm1vZGUpXG4gICAgICAgICAgICBlbnRlckxvY2FsTW9kZShjb25maWcsIHN0YXRlLCBydWxlLmRhdGEubW9kZSwgcnVsZS50b2tlbik7XG4gICAgICAgICAgaWYgKHJ1bGUuZGF0YS5pbmRlbnQpXG4gICAgICAgICAgICBzdGF0ZS5pbmRlbnQucHVzaChzdHJlYW0uaW5kZW50YXRpb24oKSArIGNvbmZpZy5pbmRlbnRVbml0KTtcbiAgICAgICAgICBpZiAocnVsZS5kYXRhLmRlZGVudClcbiAgICAgICAgICAgIHN0YXRlLmluZGVudC5wb3AoKTtcbiAgICAgICAgICB2YXIgdG9rZW4gPSBydWxlLnRva2VuXG4gICAgICAgICAgaWYgKHRva2VuICYmIHRva2VuLmFwcGx5KSB0b2tlbiA9IHRva2VuKG1hdGNoZXMpXG4gICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMiAmJiBydWxlLnRva2VuICYmIHR5cGVvZiBydWxlLnRva2VuICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAyOyBqIDwgbWF0Y2hlcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgaWYgKG1hdGNoZXNbal0pXG4gICAgICAgICAgICAgICAgKHN0YXRlLnBlbmRpbmcgfHwgKHN0YXRlLnBlbmRpbmcgPSBbXSkpLnB1c2goe3RleHQ6IG1hdGNoZXNbal0sIHRva2VuOiBydWxlLnRva2VuW2ogLSAxXX0pO1xuICAgICAgICAgICAgc3RyZWFtLmJhY2tVcChtYXRjaGVzWzBdLmxlbmd0aCAtIChtYXRjaGVzWzFdID8gbWF0Y2hlc1sxXS5sZW5ndGggOiAwKSk7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5bMF07XG4gICAgICAgICAgfSBlbHNlIGlmICh0b2tlbiAmJiB0b2tlbi5qb2luKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5bMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY21wKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFhIHx8IHR5cGVvZiBhICE9IFwib2JqZWN0XCIgfHwgIWIgfHwgdHlwZW9mIGIgIT0gXCJvYmplY3RcIikgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBwcm9wcyA9IDA7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBhKSBpZiAoYS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgaWYgKCFiLmhhc093blByb3BlcnR5KHByb3ApIHx8ICFjbXAoYVtwcm9wXSwgYltwcm9wXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHByb3BzKys7XG4gICAgfVxuICAgIGZvciAodmFyIHByb3AgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocHJvcCkpIHByb3BzLS07XG4gICAgcmV0dXJuIHByb3BzID09IDA7XG4gIH1cblxuICBmdW5jdGlvbiBlbnRlckxvY2FsTW9kZShjb25maWcsIHN0YXRlLCBzcGVjLCB0b2tlbikge1xuICAgIHZhciBwZXJzO1xuICAgIGlmIChzcGVjLnBlcnNpc3RlbnQpIGZvciAodmFyIHAgPSBzdGF0ZS5wZXJzaXN0ZW50U3RhdGVzOyBwICYmICFwZXJzOyBwID0gcC5uZXh0KVxuICAgICAgaWYgKHNwZWMuc3BlYyA/IGNtcChzcGVjLnNwZWMsIHAuc3BlYykgOiBzcGVjLm1vZGUgPT0gcC5tb2RlKSBwZXJzID0gcDtcbiAgICB2YXIgbW9kZSA9IHBlcnMgPyBwZXJzLm1vZGUgOiBzcGVjLm1vZGUgfHwgQ29kZU1pcnJvci5nZXRNb2RlKGNvbmZpZywgc3BlYy5zcGVjKTtcbiAgICB2YXIgbFN0YXRlID0gcGVycyA/IHBlcnMuc3RhdGUgOiBDb2RlTWlycm9yLnN0YXJ0U3RhdGUobW9kZSk7XG4gICAgaWYgKHNwZWMucGVyc2lzdGVudCAmJiAhcGVycylcbiAgICAgIHN0YXRlLnBlcnNpc3RlbnRTdGF0ZXMgPSB7bW9kZTogbW9kZSwgc3BlYzogc3BlYy5zcGVjLCBzdGF0ZTogbFN0YXRlLCBuZXh0OiBzdGF0ZS5wZXJzaXN0ZW50U3RhdGVzfTtcblxuICAgIHN0YXRlLmxvY2FsU3RhdGUgPSBsU3RhdGU7XG4gICAgc3RhdGUubG9jYWwgPSB7bW9kZTogbW9kZSxcbiAgICAgICAgICAgICAgICAgICBlbmQ6IHNwZWMuZW5kICYmIHRvUmVnZXgoc3BlYy5lbmQpLFxuICAgICAgICAgICAgICAgICAgIGVuZFNjYW46IHNwZWMuZW5kICYmIHNwZWMuZm9yY2VFbmQgIT09IGZhbHNlICYmIHRvUmVnZXgoc3BlYy5lbmQsIGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICBlbmRUb2tlbjogdG9rZW4gJiYgdG9rZW4uam9pbiA/IHRva2VuW3Rva2VuLmxlbmd0aCAtIDFdIDogdG9rZW59O1xuICB9XG5cbiAgZnVuY3Rpb24gaW5kZXhPZih2YWwsIGFycikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBpZiAoYXJyW2ldID09PSB2YWwpIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5kZW50RnVuY3Rpb24oc3RhdGVzLCBtZXRhKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIsIGxpbmUpIHtcbiAgICAgIGlmIChzdGF0ZS5sb2NhbCAmJiBzdGF0ZS5sb2NhbC5tb2RlLmluZGVudClcbiAgICAgICAgcmV0dXJuIHN0YXRlLmxvY2FsLm1vZGUuaW5kZW50KHN0YXRlLmxvY2FsU3RhdGUsIHRleHRBZnRlciwgbGluZSk7XG4gICAgICBpZiAoc3RhdGUuaW5kZW50ID09IG51bGwgfHwgc3RhdGUubG9jYWwgfHwgbWV0YS5kb250SW5kZW50U3RhdGVzICYmIGluZGV4T2Yoc3RhdGUuc3RhdGUsIG1ldGEuZG9udEluZGVudFN0YXRlcykgPiAtMSlcbiAgICAgICAgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcblxuICAgICAgdmFyIHBvcyA9IHN0YXRlLmluZGVudC5sZW5ndGggLSAxLCBydWxlcyA9IHN0YXRlc1tzdGF0ZS5zdGF0ZV07XG4gICAgICBzY2FuOiBmb3IgKDs7KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcnVsZSA9IHJ1bGVzW2ldO1xuICAgICAgICAgIGlmIChydWxlLmRhdGEuZGVkZW50ICYmIHJ1bGUuZGF0YS5kZWRlbnRJZkxpbmVTdGFydCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhciBtID0gcnVsZS5yZWdleC5leGVjKHRleHRBZnRlcik7XG4gICAgICAgICAgICBpZiAobSAmJiBtWzBdKSB7XG4gICAgICAgICAgICAgIHBvcy0tO1xuICAgICAgICAgICAgICBpZiAocnVsZS5uZXh0IHx8IHJ1bGUucHVzaCkgcnVsZXMgPSBzdGF0ZXNbcnVsZS5uZXh0IHx8IHJ1bGUucHVzaF07XG4gICAgICAgICAgICAgIHRleHRBZnRlciA9IHRleHRBZnRlci5zbGljZShtWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIHNjYW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvcyA8IDAgPyAwIDogc3RhdGUuaW5kZW50W3Bvc107XG4gICAgfTtcbiAgfVxufSk7XG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBUZXh0RmlsZVZpZXcsIFdvcmtzcGFjZUxlYWYsIE1hcmtkb3duVmlldyB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IFwiLi9zcmMvbm9yZy1wYXJzZS5qc1wiO1xuaW1wb3J0IFwiLi9saWIvY29kZW1pcnJvci5qc1wiO1xuaW1wb3J0IFwiLi9tb2RlL3NpbXBsZS9zaW1wbGUuanNcIjtcblxuaW1wb3J0IHtcbiAgVmlld1VwZGF0ZSxcbiAgUGx1Z2luVmFsdWUsXG4gIEVkaXRvclZpZXcsXG4gIFZpZXdQbHVnaW4sXG59IGZyb20gXCJAY29kZW1pcnJvci92aWV3XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lU2ltcGxlTW9kZShcIm5lb3JnXCIsIHtcblx0c3RhcnQ6IFtcblx0XHR7cmVnZXg6IC9eXFwqIC4qJC8sIHRva2VuOiBbXCJoZWFkZXItMVwiLCBcImhlYWRlclwiXSwgc29sIDogdHJ1ZSB9LFxuXHRcdHtyZWdleDogL15cXCpcXCogLiovLCB0b2tlbjogW1wiaGVhZGVyLTJcIiwgXCJoZWFkZXJcIl0sIHNvbDogdHJ1ZSB9LFxuXHRcdHtyZWdleDogL15cXCpcXCpcXCogLiovLCB0b2tlbjogW1wiaGVhZGVyLTNcIiwgXCJoZWFkZXJcIl0sIHNvbDogdHJ1ZSB9LFxuXG5cdFx0e3JlZ2V4OiAvXlxccypcXH4uKiQvLCB0b2tlbjogW1wibGlzdC1pdGVtXCJdLCBzb2wgOiB0cnVlIH0sXG5cbiAgICAgICAge3JlZ2V4OiBcIlxcLyguKj8pXFwvXCIsIHRva2VuOiBbXCJpdGFsaWNcIl19LFxuICAgICAgICB7cmVnZXg6IC9cXCooLio/KVxcKi8sIHRva2VuOiBbXCJib2xkXCJdfSxcbiAgICAgICAgXG5cdF0sXG5cblx0ZW52OiBbXG5cdFx0e3JlZ2V4OiAvXFwjXFwrKD86KEVORHxlbmQpKV9bYS16QS1aXSovLCB0b2tlbjogXCJjb21tZW50XCIsIG5leHQ6IFwic3RhcnRcIiwgc29sOiB0cnVlfSxcblx0XHR7cmVnZXg6IC8uKi8sIHRva2VuOiBcImNvbW1lbnRcIn1cblx0XVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5lb3JnIGV4dGVuZHMgUGx1Z2luIHtcbiAgICBhc3luYyBvbmxvYWQoKSB7XG4gICAgICAgIHN1cGVyLm9ubG9hZCgpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRpbmcgTmVvcmcgcGx1Z2luIC4uLlwiKTtcblxuICAgICAgICB0aGlzLnJlZ2lzdGVyVmlldyhcIm5lb3JnXCIsIHRoaXMubmVvcmdWaWV3Q3JlYXRvcik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJFeHRlbnNpb25zKFtcIm5vcmdcIl0sIFwibmVvcmdcIik7XG4gICAgfVxuXG4gICAgbmVvcmdWaWV3Q3JlYXRvciA9IChsZWFmOiBXb3Jrc3BhY2VMZWFmKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgTmVvcmdWaWV3KGxlYWYpO1xuICAgIH07XG5cbiAgICBvbnVubG9hZCgpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJVbmxvYWRpbmcgTmVvcmcgcGx1Z2luIC4uLlwiKTtcbiAgICB9XG59XG5cbmNsYXNzIE5lb3JnVmlldyBleHRlbmRzIFRleHRGaWxlVmlldyB7XG4gICAgLy8gSW50ZXJuYWwgY29kZSBtaXJyb3IgaW5zdGFuY2U6XG4gICAgY29kZU1pcnJvcjogQ29kZU1pcnJvci5FZGl0b3I7XG5cbiAgICAvLyB0aGlzLmNvbnRlbnRFbCBpcyBub3QgZXhwb3NlZCwgc28gY2hlYXQgYSBiaXQuXG4gICAgcHVibGljIGdldCBleHRDb250ZW50RWwoKTogSFRNTEVsZW1lbnQge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRFbDtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihsZWFmOiBXb3Jrc3BhY2VMZWFmKSB7XG4gICAgICAgIHN1cGVyKGxlYWYpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuY29kZU1pcnJvciA9IENvZGVNaXJyb3IodGhpcy5leHRDb250ZW50RWwsIHtcbiAgICAgICAgICAgIHNob3dDdXJzb3JXaGVuU2VsZWN0aW5nOiB0cnVlLFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iub24oXCJjaGFuZ2VzXCIsIHRoaXMuY2hhbmdlZCk7XG5cbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldEN1cnNvcigwLCAwKTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIHRoZSB2aWV3IGlzIHJlc2l6ZWQsIHJlZnJlc2ggQ29kZU1pcnJvciAodGhhbmtzIExpY2F0ISkuXG4gICAgb25SZXNpemUoKSB7XG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5yZWZyZXNoKCk7XG4gICAgfVxuXG4gICAgY2hhbmdlZCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U2F2ZSgpO1xuICAgIH07XG5cbiAgICBnZXRWaWV3RGF0YSA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZU1pcnJvci5nZXRWYWx1ZSgpO1xuICAgIH07XG5cbiAgICBzZXRWaWV3RGF0YSA9IChkYXRhOiBzdHJpbmcsIGNsZWFyOiBib29sZWFuKSA9PiB7XG4gICAgICAgIGlmIChjbGVhcikge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnN3YXBEb2MoQ29kZU1pcnJvci5Eb2MoZGF0YSwgXCJuZW9yZ1wiKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0VmFsdWUoZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmICh0aGlzLmFwcD8udmF1bHQ/LmNvbmZpZz8udmltTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcImtleU1hcFwiLCBcInZpbVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgc2VlbXMgdG8gZml4IHNvbWUgb2RkIHZpc3VhbCBidWdzOlxuICAgICAgICB0aGlzLmNvZGVNaXJyb3IucmVmcmVzaCgpO1xuXG4gICAgICAgIC8vIFRoaXMgZm9jdXNlcyB0aGUgZWRpdG9yLCB3aGljaCBpcyBhbmFsb2dvdXMgdG8gdGhlXG4gICAgICAgIC8vIGRlZmF1bHQgTWFya2Rvd24gYmVoYXZpb3IgaW4gT2JzaWRpYW46XG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5mb2N1cygpO1xuICAgIH07XG5cbiAgICBjbGVhciA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldFZhbHVlKFwiXCIpO1xuICAgICAgICB0aGlzLmNvZGVNaXJyb3IuY2xlYXJIaXN0b3J5KCk7XG4gICAgfTtcblxuICAgIGdldERpc3BsYXlUZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5maWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlLmJhc2VuYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwib3JnIChObyBGaWxlKVwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2FuQWNjZXB0RXh0ZW5zaW9uKGV4dGVuc2lvbjogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBleHRlbnNpb24gPT09IFwibm9yZ1wiIDtcbiAgICB9XG5cbiAgICBnZXRWaWV3VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwibmVvcmdcIjtcbiAgICB9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQSwrQkFBQUEsU0FBQTtBQUFBLElBQUFBLFFBQU8sVUFBVTtBQUFBO0FBQUE7OztBQ0FqQjtBQUFBLG1DQUFBQyxTQUFBO0FBR0EsS0FBQyxTQUFTLEtBQUs7QUFDYixVQUFJLE9BQU8sV0FBVyxZQUFZLE9BQU9BLFdBQVU7QUFDakQsWUFBSSxvQkFBK0I7QUFBQSxlQUM1QixPQUFPLFVBQVUsY0FBYyxPQUFPO0FBQzdDLGVBQU8sQ0FBQyxzQkFBc0IsR0FBRyxHQUFHO0FBQUE7QUFFcEMsWUFBSSxVQUFVO0FBQUEsSUFDbEIsR0FBRyxTQUFTQyxhQUFZO0FBQ3RCO0FBRUEsTUFBQUEsWUFBVyxtQkFBbUIsU0FBUyxNQUFNLFFBQVE7QUFDbkQsUUFBQUEsWUFBVyxXQUFXLE1BQU0sU0FBUyxRQUFRO0FBQzNDLGlCQUFPQSxZQUFXLFdBQVcsUUFBUSxNQUFNO0FBQUEsUUFDN0MsQ0FBQztBQUFBLE1BQ0g7QUFFQSxNQUFBQSxZQUFXLGFBQWEsU0FBUyxRQUFRLFFBQVE7QUFDL0Msb0JBQVksUUFBUSxPQUFPO0FBQzNCLFlBQUksVUFBVSxDQUFDLEdBQUcsT0FBTyxPQUFPLFFBQVEsQ0FBQyxHQUFHLGlCQUFpQjtBQUM3RCxpQkFBUyxTQUFTO0FBQVEsY0FBSSxTQUFTLFFBQVEsT0FBTyxlQUFlLEtBQUssR0FBRztBQUMzRSxnQkFBSSxPQUFPLFFBQVEsS0FBSyxJQUFJLENBQUMsR0FBRyxPQUFPLE9BQU8sS0FBSztBQUNuRCxxQkFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsS0FBSztBQUNwQyxrQkFBSSxPQUFPLEtBQUssQ0FBQztBQUNqQixtQkFBSyxLQUFLLElB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QztBQUFBLEVBTUEsV0FBVztBQUNQLFlBQVEsSUFBSSw0QkFBNEI7QUFBQSxFQUM1QztBQUNKO0FBRUEsSUFBTSxZQUFOLGNBQXdCLDZCQUFhO0FBQUEsRUFVakMsWUFBWSxNQUFxQjtBQUM3QixVQUFNLElBQUk7QUFnQmQsbUJBQVUsWUFBWTtBQUNsQixXQUFLLFlBQVk7QUFBQSxJQUNyQjtBQUVBLHVCQUFjLE1BQU07QUFDaEIsYUFBTyxLQUFLLFdBQVcsU0FBUztBQUFBLElBQ3BDO0FBRUEsdUJBQWMsQ0FBQyxNQUFjLFVBQW1CO0FBcEZwRDtBQXFGUSxVQUFJLE9BQU87QUFFUCxhQUFLLFdBQVcsUUFBUSxXQUFXLElBQUksTUFBTSxPQUFPLENBQUM7QUFBQSxNQUN6RCxPQUFPO0FBQ0gsYUFBSyxXQUFXLFNBQVMsSUFBSTtBQUFBLE1BQ2pDO0FBR0EsV0FBSSxzQkFBSyxRQUFMLG1CQUFVLFVBQVYsbUJBQWlCLFdBQWpCLG1CQUF5QixTQUFTO0FBQ2xDLGFBQUssV0FBVyxVQUFVLFVBQVUsS0FBSztBQUFBLE1BQzdDO0FBR0EsV0FBSyxXQUFXLFFBQVE7QUFJeEIsV0FBSyxXQUFXLE1BQU07QUFBQSxJQUMxQjtBQUVBLGlCQUFRLE1BQU07QUFDVixXQUFLLFdBQVcsU0FBUyxFQUFFO0FBQzNCLFdBQUssV0FBVyxhQUFhO0FBQUEsSUFDakM7QUE5Q0ksU0FBSyxhQUFhLFdBQVcsS0FBSyxjQUFjO0FBQUEsTUFDNUMseUJBQXlCO0FBQUEsSUFDN0IsQ0FBQztBQUVELFNBQUssV0FBVyxHQUFHLFdBQVcsS0FBSyxPQUFPO0FBRTFDLFNBQUssV0FBVyxVQUFVLEdBQUcsQ0FBQztBQUFBLEVBQ2xDO0FBQUE7QUFBQSxFQWZBLElBQVcsZUFBNEI7QUFFbkMsV0FBTyxLQUFLO0FBQUEsRUFDaEI7QUFBQTtBQUFBLEVBZUEsV0FBVztBQUNQLFNBQUssV0FBVyxRQUFRO0FBQUEsRUFDNUI7QUFBQSxFQW9DQSxpQkFBaUI7QUFDYixRQUFJLEtBQUssTUFBTTtBQUNYLGFBQU8sS0FBSyxLQUFLO0FBQUEsSUFDckIsT0FBTztBQUNILGFBQU87QUFBQSxJQUNYO0FBQUEsRUFDSjtBQUFBLEVBRUEsbUJBQW1CLFdBQW1CO0FBQ2xDLFdBQU8sY0FBYztBQUFBLEVBQ3pCO0FBQUEsRUFFQSxjQUFjO0FBQ1YsV0FBTztBQUFBLEVBQ1g7QUFDSjsiLAogICJuYW1lcyI6IFsibW9kdWxlIiwgIm1vZHVsZSIsICJDb2RlTWlycm9yIiwgInN0YXRlIl0KfQo=
