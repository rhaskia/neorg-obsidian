/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// lib/codemirror.js
var require_codemirror = __commonJS({
  "lib/codemirror.js"(exports, module2) {
    module2.exports = CodeMirror;
  }
});

// mode/simple/simple.js
var require_simple = __commonJS({
  "mode/simple/simple.js"(exports, module2) {
    (function(mod) {
      if (typeof exports == "object" && typeof module2 == "object")
        mod(require_codemirror());
      else if (typeof define == "function" && define.amd)
        define(["../../lib/codemirror"], mod);
      else
        mod(CodeMirror);
    })(function(CodeMirror3) {
      "use strict";
      CodeMirror3.defineSimpleMode = function(name, states) {
        CodeMirror3.defineMode(name, function(config) {
          return CodeMirror3.simpleMode(config, states);
        });
      };
      CodeMirror3.simpleMode = function(config, states) {
        ensureState(states, "start");
        var states_ = {}, meta = states.meta || {}, hasIndentation = false;
        for (var state in states)
          if (state != meta && states.hasOwnProperty(state)) {
            var list = states_[state] = [], orig = states[state];
            for (var i = 0; i < orig.length; i++) {
              var data = orig[i];
              list.push(new Rule(data, states));
              if (data.indent || data.dedent)
                hasIndentation = true;
            }
          }
        var mode = {
          startState: function() {
            return {
              state: "start",
              pending: null,
              local: null,
              localState: null,
              indent: hasIndentation ? [] : null
            };
          },
          copyState: function(state2) {
            var s = {
              state: state2.state,
              pending: state2.pending,
              local: state2.local,
              localState: null,
              indent: state2.indent && state2.indent.slice(0)
            };
            if (state2.localState)
              s.localState = CodeMirror3.copyState(state2.local.mode, state2.localState);
            if (state2.stack)
              s.stack = state2.stack.slice(0);
            for (var pers = state2.persistentStates; pers; pers = pers.next)
              s.persistentStates = {
                mode: pers.mode,
                spec: pers.spec,
                state: pers.state == state2.localState ? s.localState : CodeMirror3.copyState(pers.mode, pers.state),
                next: s.persistentStates
              };
            return s;
          },
          token: tokenFunction(states_, config),
          innerMode: function(state2) {
            return state2.local && { mode: state2.local.mode, state: state2.localState };
          },
          indent: indentFunction(states_, meta)
        };
        if (meta) {
          for (var prop in meta)
            if (meta.hasOwnProperty(prop))
              mode[prop] = meta[prop];
        }
        return mode;
      };
      function ensureState(states, name) {
        if (!states.hasOwnProperty(name))
          throw new Error("Undefined state " + name + " in simple mode");
      }
      function toRegex(val, caret) {
        if (!val)
          return /(?:)/;
        var flags = "";
        if (val instanceof RegExp) {
          if (val.ignoreCase)
            flags = "i";
          if (val.unicode)
            flags += "u";
          val = val.source;
        } else {
          val = String(val);
        }
        return new RegExp((caret === false ? "" : "^") + "(?:" + val + ")", flags);
      }
      function asToken(val) {
        if (!val)
          return null;
        if (val.apply)
          return val;
        if (typeof val == "string")
          return val.replace(/\./g, " ");
        var result = [];
        for (var i = 0; i < val.length; i++)
          result.push(val[i] && val[i].replace(/\./g, " "));
        return result;
      }
      function Rule(data, states) {
        if (data.next || data.push)
          ensureState(states, data.next || data.push);
        this.regex = toRegex(data.regex);
        this.token = asToken(data.token);
        this.data = data;
      }
      function tokenFunction(states, config) {
        return function(stream, state) {
          if (state.pending) {
            var pend = state.pending.shift();
            if (state.pending.length == 0)
              state.pending = null;
            stream.pos += pend.text.length;
            return pend.token;
          }
          if (state.local) {
            if (state.local.end && stream.match(state.local.end)) {
              var tok = state.local.endToken || null;
              state.local = state.localState = null;
              return tok;
            } else {
              var tok = state.local.mode.token(stream, state.localState), m;
              if (state.local.endScan && (m = state.local.endScan.exec(stream.current())))
                stream.pos = stream.start + m.index;
              return tok;
            }
          }
          var curState = states[state.state];
          for (var i = 0; i < curState.length; i++) {
            var rule = curState[i];
            var matches = (!rule.data.sol || stream.sol()) && stream.match(rule.regex);
            if (matches) {
              if (rule.data.next) {
                state.state = rule.data.next;
              } else if (rule.data.push) {
                (state.stack || (state.stack = [])).push(state.state);
                state.state = rule.data.push;
              } else if (rule.data.pop && state.stack && state.stack.length) {
                state.state = state.stack.pop();
              }
              if (rule.data.mode)
                enterLocalMode(config, state, rule.data.mode, rule.token);
              if (rule.data.indent)
                state.indent.push(stream.indentation() + config.indentUnit);
              if (rule.data.dedent)
                state.indent.pop();
              var token = rule.token;
              if (token && token.apply)
                token = token(matches);
              if (matches.length > 2 && rule.token && typeof rule.token != "string") {
                for (var j = 2; j < matches.length; j++)
                  if (matches[j])
                    (state.pending || (state.pending = [])).push({ text: matches[j], token: rule.token[j - 1] });
                stream.backUp(matches[0].length - (matches[1] ? matches[1].length : 0));
                return token[0];
              } else if (token && token.join) {
                return token[0];
              } else {
                return token;
              }
            }
          }
          stream.next();
          return null;
        };
      }
      function cmp(a, b) {
        if (a === b)
          return true;
        if (!a || typeof a != "object" || !b || typeof b != "object")
          return false;
        var props = 0;
        for (var prop in a)
          if (a.hasOwnProperty(prop)) {
            if (!b.hasOwnProperty(prop) || !cmp(a[prop], b[prop]))
              return false;
            props++;
          }
        for (var prop in b)
          if (b.hasOwnProperty(prop))
            props--;
        return props == 0;
      }
      function enterLocalMode(config, state, spec, token) {
        var pers;
        if (spec.persistent) {
          for (var p = state.persistentStates; p && !pers; p = p.next)
            if (spec.spec ? cmp(spec.spec, p.spec) : spec.mode == p.mode)
              pers = p;
        }
        var mode = pers ? pers.mode : spec.mode || CodeMirror3.getMode(config, spec.spec);
        var lState = pers ? pers.state : CodeMirror3.startState(mode);
        if (spec.persistent && !pers)
          state.persistentStates = { mode, spec: spec.spec, state: lState, next: state.persistentStates };
        state.localState = lState;
        state.local = {
          mode,
          end: spec.end && toRegex(spec.end),
          endScan: spec.end && spec.forceEnd !== false && toRegex(spec.end, false),
          endToken: token && token.join ? token[token.length - 1] : token
        };
      }
      function indexOf(val, arr) {
        for (var i = 0; i < arr.length; i++)
          if (arr[i] === val)
            return true;
      }
      function indentFunction(states, meta) {
        return function(state, textAfter, line) {
          if (state.local && state.local.mode.indent)
            return state.local.mode.indent(state.localState, textAfter, line);
          if (state.indent == null || state.local || meta.dontIndentStates && indexOf(state.state, meta.dontIndentStates) > -1)
            return CodeMirror3.Pass;
          var pos = state.indent.length - 1, rules = states[state.state];
          scan:
            for (; ; ) {
              for (var i = 0; i < rules.length; i++) {
                var rule = rules[i];
                if (rule.data.dedent && rule.data.dedentIfLineStart !== false) {
                  var m = rule.regex.exec(textAfter);
                  if (m && m[0]) {
                    pos--;
                    if (rule.next || rule.push)
                      rules = states[rule.next || rule.push];
                    textAfter = textAfter.slice(m[0].length);
                    continue scan;
                  }
                }
              }
              break;
            }
          return pos < 0 ? 0 : state.indent[pos];
        };
      }
    });
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Neorg
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_codemirror = __toESM(require_codemirror());
var import_simple = __toESM(require_simple());
var import_view = require("@codemirror/view");
var import_codemirror2 = __toESM(require_codemirror());
import_codemirror2.default.defineSimpleMode("neorg", {
  start: [
    { regex: /^\* .*$/, token: ["header-1", "header"], sol: true },
    { regex: /^\*\* .*/, token: ["header-2", "header"], sol: true },
    { regex: /^\*\*\* .*/, token: ["header-3", "header"], sol: true },
    { regex: /^\s*\~.*$/, token: ["list-item"], sol: true },
    { regex: "/(.*?)/", token: ["italic"] },
    { regex: /\*(.*?)\*/, token: ["bold"] },
    { regex: /`([^`]+)`/, token: ["inline-code"] },
    { regex: /^\s*- \( \)/, token: ["todo"], sol: true },
    { regex: /^\s*- \(x\)/, token: ["todo"], sol: true }
  ],
  env: [
    { regex: /\#\+(?:(END|end))_[a-zA-Z]*/, token: "comment", next: "start", sol: true },
    { regex: /.*/, token: "comment" }
  ]
});
var Neorg = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.neorgViewCreator = (leaf) => {
      return new NeorgView(leaf);
    };
  }
  async onload() {
    super.onload();
    console.log("Loading Neorg plugin ...");
    this.registerView("neorg", this.neorgViewCreator);
    this.registerExtensions(["norg"], "neorg");
    this.addRibbonIcon("plus", "New norg file", () => {
    });
  }
  newNeorgFile() {
    this.app.vault.create("untitled2.norg", "").then((file) => {
      var _a;
      return (_a = this.app.workspace.getMostRecentLeaf()) == null ? void 0 : _a.openFile(file);
    });
  }
  onunload() {
    console.log("Unloading Neorg plugin ...");
  }
};
var NeorgView = class extends import_obsidian.TextFileView {
  constructor(leaf) {
    super(leaf);
    this.changed = async () => {
      this.requestSave();
      this.reloadButtons();
    };
    this.getViewData = () => {
      return this.codeMirror.getValue();
    };
    this.setViewData = (data, clear) => {
      if (clear) {
        this.codeMirror.swapDoc(import_codemirror2.default.Doc(data, "neorg"));
      } else {
        this.codeMirror.setValue(data);
      }
      this.codeMirror.refresh();
      this.codeMirror.focus();
      this.reloadButtons();
    };
    this.clear = () => {
      this.codeMirror.setValue("");
      this.codeMirror.clearHistory();
    };
    this.codeMirror = (0, import_codemirror2.default)(this.extContentEl, {
      showCursorWhenSelecting: true
    });
    this.codeMirror.on("changes", this.changed);
  }
  // this.contentEl is not exposed, so cheat a bit.
  get extContentEl() {
    return this.contentEl;
  }
  // When the view is resized, refresh CodeMirror (thanks Licat!).
  onResize() {
    this.codeMirror.refresh();
    this.reloadButtons();
  }
  reloadButtons() {
    const todoElements = this.contentEl.querySelectorAll(".todo");
    todoElements.forEach((todoElement) => {
      todoElement.remove();
    });
    var rect = this.codeMirror.getWrapperElement().getBoundingClientRect();
    var topVisibleLine = this.codeMirror.lineAtHeight(rect.top, "window");
    var bottomVisibleLine = this.codeMirror.lineAtHeight(rect.bottom, "window");
    for (let i = topVisibleLine; i < bottomVisibleLine; i++) {
      let tokens = this.codeMirror.getLineTokens(i);
      for (let j = 0; j < tokens.length; j++) {
        if (tokens[j].type == "todo") {
          this.todoButton(tokens[j], i);
        }
      }
    }
  }
  todoButton(token, line) {
    let lines = this.contentEl.querySelector(".CodeMirror-lines");
    if (lines) {
      let button = lines.createEl("input");
      button.type = "checkbox";
      button.className = "todo";
      const coords = this.codeMirror.charCoords({ line, ch: token.start }, "local");
      button.style.left = coords.left.toString() + "px";
      button.style.top = coords.top.toString() + "px";
      button.checked = token.string == "- (x)";
      let cm = this.codeMirror;
      button.addEventListener("change", () => {
        const newText = button.checked ? "- (x)" : "- ( )";
        this.codeMirror.replaceRange(newText, { line, ch: token.start }, { line, ch: token.end });
      });
    }
  }
  getDisplayText() {
    if (this.file) {
      return this.file.basename;
    } else {
      return "org (No File)";
    }
  }
  canAcceptExtension(extension) {
    return extension === "norg";
  }
  getViewType() {
    return "neorg";
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibGliL2NvZGVtaXJyb3IuanMiLCAibW9kZS9zaW1wbGUvc2ltcGxlLmpzIiwgIm1haW4udHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIm1vZHVsZS5leHBvcnRzID0gQ29kZU1pcnJvcjtcblxuIiwgIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lU2ltcGxlTW9kZSA9IGZ1bmN0aW9uKG5hbWUsIHN0YXRlcykge1xuICAgIENvZGVNaXJyb3IuZGVmaW5lTW9kZShuYW1lLCBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHJldHVybiBDb2RlTWlycm9yLnNpbXBsZU1vZGUoY29uZmlnLCBzdGF0ZXMpO1xuICAgIH0pO1xuICB9O1xuXG4gIENvZGVNaXJyb3Iuc2ltcGxlTW9kZSA9IGZ1bmN0aW9uKGNvbmZpZywgc3RhdGVzKSB7XG4gICAgZW5zdXJlU3RhdGUoc3RhdGVzLCBcInN0YXJ0XCIpO1xuICAgIHZhciBzdGF0ZXNfID0ge30sIG1ldGEgPSBzdGF0ZXMubWV0YSB8fCB7fSwgaGFzSW5kZW50YXRpb24gPSBmYWxzZTtcbiAgICBmb3IgKHZhciBzdGF0ZSBpbiBzdGF0ZXMpIGlmIChzdGF0ZSAhPSBtZXRhICYmIHN0YXRlcy5oYXNPd25Qcm9wZXJ0eShzdGF0ZSkpIHtcbiAgICAgIHZhciBsaXN0ID0gc3RhdGVzX1tzdGF0ZV0gPSBbXSwgb3JpZyA9IHN0YXRlc1tzdGF0ZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yaWcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGRhdGEgPSBvcmlnW2ldO1xuICAgICAgICBsaXN0LnB1c2gobmV3IFJ1bGUoZGF0YSwgc3RhdGVzKSk7XG4gICAgICAgIGlmIChkYXRhLmluZGVudCB8fCBkYXRhLmRlZGVudCkgaGFzSW5kZW50YXRpb24gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbW9kZSA9IHtcbiAgICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge3N0YXRlOiBcInN0YXJ0XCIsIHBlbmRpbmc6IG51bGwsXG4gICAgICAgICAgICAgICAgbG9jYWw6IG51bGwsIGxvY2FsU3RhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgaW5kZW50OiBoYXNJbmRlbnRhdGlvbiA/IFtdIDogbnVsbH07XG4gICAgICB9LFxuICAgICAgY29weVN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICB2YXIgcyA9IHtzdGF0ZTogc3RhdGUuc3RhdGUsIHBlbmRpbmc6IHN0YXRlLnBlbmRpbmcsXG4gICAgICAgICAgICAgICAgIGxvY2FsOiBzdGF0ZS5sb2NhbCwgbG9jYWxTdGF0ZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgaW5kZW50OiBzdGF0ZS5pbmRlbnQgJiYgc3RhdGUuaW5kZW50LnNsaWNlKDApfTtcbiAgICAgICAgaWYgKHN0YXRlLmxvY2FsU3RhdGUpXG4gICAgICAgICAgcy5sb2NhbFN0YXRlID0gQ29kZU1pcnJvci5jb3B5U3RhdGUoc3RhdGUubG9jYWwubW9kZSwgc3RhdGUubG9jYWxTdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5zdGFjaylcbiAgICAgICAgICBzLnN0YWNrID0gc3RhdGUuc3RhY2suc2xpY2UoMCk7XG4gICAgICAgIGZvciAodmFyIHBlcnMgPSBzdGF0ZS5wZXJzaXN0ZW50U3RhdGVzOyBwZXJzOyBwZXJzID0gcGVycy5uZXh0KVxuICAgICAgICAgIHMucGVyc2lzdGVudFN0YXRlcyA9IHttb2RlOiBwZXJzLm1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWM6IHBlcnMuc3BlYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHBlcnMuc3RhdGUgPT0gc3RhdGUubG9jYWxTdGF0ZSA/IHMubG9jYWxTdGF0ZSA6IENvZGVNaXJyb3IuY29weVN0YXRlKHBlcnMubW9kZSwgcGVycy5zdGF0ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQ6IHMucGVyc2lzdGVudFN0YXRlc307XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfSxcbiAgICAgIHRva2VuOiB0b2tlbkZ1bmN0aW9uKHN0YXRlc18sIGNvbmZpZyksXG4gICAgICBpbm5lck1vZGU6IGZ1bmN0aW9uKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5sb2NhbCAmJiB7bW9kZTogc3RhdGUubG9jYWwubW9kZSwgc3RhdGU6IHN0YXRlLmxvY2FsU3RhdGV9OyB9LFxuICAgICAgaW5kZW50OiBpbmRlbnRGdW5jdGlvbihzdGF0ZXNfLCBtZXRhKVxuICAgIH07XG4gICAgaWYgKG1ldGEpIGZvciAodmFyIHByb3AgaW4gbWV0YSkgaWYgKG1ldGEuaGFzT3duUHJvcGVydHkocHJvcCkpXG4gICAgICBtb2RlW3Byb3BdID0gbWV0YVtwcm9wXTtcbiAgICByZXR1cm4gbW9kZTtcbiAgfTtcblxuICBmdW5jdGlvbiBlbnN1cmVTdGF0ZShzdGF0ZXMsIG5hbWUpIHtcbiAgICBpZiAoIXN0YXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZGVmaW5lZCBzdGF0ZSBcIiArIG5hbWUgKyBcIiBpbiBzaW1wbGUgbW9kZVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvUmVnZXgodmFsLCBjYXJldCkge1xuICAgIGlmICghdmFsKSByZXR1cm4gLyg/OikvO1xuICAgIHZhciBmbGFncyA9IFwiXCI7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgaWYgKHZhbC5pZ25vcmVDYXNlKSBmbGFncyA9IFwiaVwiO1xuICAgICAgaWYgKHZhbC51bmljb2RlKSBmbGFncyArPSBcInVcIlxuICAgICAgdmFsID0gdmFsLnNvdXJjZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gU3RyaW5nKHZhbCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVnRXhwKChjYXJldCA9PT0gZmFsc2UgPyBcIlwiIDogXCJeXCIpICsgXCIoPzpcIiArIHZhbCArIFwiKVwiLCBmbGFncyk7XG4gIH1cblxuICBmdW5jdGlvbiBhc1Rva2VuKHZhbCkge1xuICAgIGlmICghdmFsKSByZXR1cm4gbnVsbDtcbiAgICBpZiAodmFsLmFwcGx5KSByZXR1cm4gdmFsXG4gICAgaWYgKHR5cGVvZiB2YWwgPT0gXCJzdHJpbmdcIikgcmV0dXJuIHZhbC5yZXBsYWNlKC9cXC4vZywgXCIgXCIpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKylcbiAgICAgIHJlc3VsdC5wdXNoKHZhbFtpXSAmJiB2YWxbaV0ucmVwbGFjZSgvXFwuL2csIFwiIFwiKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIFJ1bGUoZGF0YSwgc3RhdGVzKSB7XG4gICAgaWYgKGRhdGEubmV4dCB8fCBkYXRhLnB1c2gpIGVuc3VyZVN0YXRlKHN0YXRlcywgZGF0YS5uZXh0IHx8IGRhdGEucHVzaCk7XG4gICAgdGhpcy5yZWdleCA9IHRvUmVnZXgoZGF0YS5yZWdleCk7XG4gICAgdGhpcy50b2tlbiA9IGFzVG9rZW4oZGF0YS50b2tlbik7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuRnVuY3Rpb24oc3RhdGVzLCBjb25maWcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0YXRlLnBlbmRpbmcpIHtcbiAgICAgICAgdmFyIHBlbmQgPSBzdGF0ZS5wZW5kaW5nLnNoaWZ0KCk7XG4gICAgICAgIGlmIChzdGF0ZS5wZW5kaW5nLmxlbmd0aCA9PSAwKSBzdGF0ZS5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgc3RyZWFtLnBvcyArPSBwZW5kLnRleHQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gcGVuZC50b2tlbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLmxvY2FsKSB7XG4gICAgICAgIGlmIChzdGF0ZS5sb2NhbC5lbmQgJiYgc3RyZWFtLm1hdGNoKHN0YXRlLmxvY2FsLmVuZCkpIHtcbiAgICAgICAgICB2YXIgdG9rID0gc3RhdGUubG9jYWwuZW5kVG9rZW4gfHwgbnVsbDtcbiAgICAgICAgICBzdGF0ZS5sb2NhbCA9IHN0YXRlLmxvY2FsU3RhdGUgPSBudWxsO1xuICAgICAgICAgIHJldHVybiB0b2s7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHRvayA9IHN0YXRlLmxvY2FsLm1vZGUudG9rZW4oc3RyZWFtLCBzdGF0ZS5sb2NhbFN0YXRlKSwgbTtcbiAgICAgICAgICBpZiAoc3RhdGUubG9jYWwuZW5kU2NhbiAmJiAobSA9IHN0YXRlLmxvY2FsLmVuZFNjYW4uZXhlYyhzdHJlYW0uY3VycmVudCgpKSkpXG4gICAgICAgICAgICBzdHJlYW0ucG9zID0gc3RyZWFtLnN0YXJ0ICsgbS5pbmRleDtcbiAgICAgICAgICByZXR1cm4gdG9rO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJTdGF0ZSA9IHN0YXRlc1tzdGF0ZS5zdGF0ZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1clN0YXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBydWxlID0gY3VyU3RhdGVbaV07XG4gICAgICAgIHZhciBtYXRjaGVzID0gKCFydWxlLmRhdGEuc29sIHx8IHN0cmVhbS5zb2woKSkgJiYgc3RyZWFtLm1hdGNoKHJ1bGUucmVnZXgpO1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgIGlmIChydWxlLmRhdGEubmV4dCkge1xuICAgICAgICAgICAgc3RhdGUuc3RhdGUgPSBydWxlLmRhdGEubmV4dDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJ1bGUuZGF0YS5wdXNoKSB7XG4gICAgICAgICAgICAoc3RhdGUuc3RhY2sgfHwgKHN0YXRlLnN0YWNrID0gW10pKS5wdXNoKHN0YXRlLnN0YXRlKTtcbiAgICAgICAgICAgIHN0YXRlLnN0YXRlID0gcnVsZS5kYXRhLnB1c2g7XG4gICAgICAgICAgfSBlbHNlIGlmIChydWxlLmRhdGEucG9wICYmIHN0YXRlLnN0YWNrICYmIHN0YXRlLnN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgc3RhdGUuc3RhdGUgPSBzdGF0ZS5zdGFjay5wb3AoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocnVsZS5kYXRhLm1vZGUpXG4gICAgICAgICAgICBlbnRlckxvY2FsTW9kZShjb25maWcsIHN0YXRlLCBydWxlLmRhdGEubW9kZSwgcnVsZS50b2tlbik7XG4gICAgICAgICAgaWYgKHJ1bGUuZGF0YS5pbmRlbnQpXG4gICAgICAgICAgICBzdGF0ZS5pbmRlbnQucHVzaChzdHJlYW0uaW5kZW50YXRpb24oKSArIGNvbmZpZy5pbmRlbnRVbml0KTtcbiAgICAgICAgICBpZiAocnVsZS5kYXRhLmRlZGVudClcbiAgICAgICAgICAgIHN0YXRlLmluZGVudC5wb3AoKTtcbiAgICAgICAgICB2YXIgdG9rZW4gPSBydWxlLnRva2VuXG4gICAgICAgICAgaWYgKHRva2VuICYmIHRva2VuLmFwcGx5KSB0b2tlbiA9IHRva2VuKG1hdGNoZXMpXG4gICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMiAmJiBydWxlLnRva2VuICYmIHR5cGVvZiBydWxlLnRva2VuICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAyOyBqIDwgbWF0Y2hlcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgaWYgKG1hdGNoZXNbal0pXG4gICAgICAgICAgICAgICAgKHN0YXRlLnBlbmRpbmcgfHwgKHN0YXRlLnBlbmRpbmcgPSBbXSkpLnB1c2goe3RleHQ6IG1hdGNoZXNbal0sIHRva2VuOiBydWxlLnRva2VuW2ogLSAxXX0pO1xuICAgICAgICAgICAgc3RyZWFtLmJhY2tVcChtYXRjaGVzWzBdLmxlbmd0aCAtIChtYXRjaGVzWzFdID8gbWF0Y2hlc1sxXS5sZW5ndGggOiAwKSk7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5bMF07XG4gICAgICAgICAgfSBlbHNlIGlmICh0b2tlbiAmJiB0b2tlbi5qb2luKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5bMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY21wKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFhIHx8IHR5cGVvZiBhICE9IFwib2JqZWN0XCIgfHwgIWIgfHwgdHlwZW9mIGIgIT0gXCJvYmplY3RcIikgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBwcm9wcyA9IDA7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBhKSBpZiAoYS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgaWYgKCFiLmhhc093blByb3BlcnR5KHByb3ApIHx8ICFjbXAoYVtwcm9wXSwgYltwcm9wXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHByb3BzKys7XG4gICAgfVxuICAgIGZvciAodmFyIHByb3AgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocHJvcCkpIHByb3BzLS07XG4gICAgcmV0dXJuIHByb3BzID09IDA7XG4gIH1cblxuICBmdW5jdGlvbiBlbnRlckxvY2FsTW9kZShjb25maWcsIHN0YXRlLCBzcGVjLCB0b2tlbikge1xuICAgIHZhciBwZXJzO1xuICAgIGlmIChzcGVjLnBlcnNpc3RlbnQpIGZvciAodmFyIHAgPSBzdGF0ZS5wZXJzaXN0ZW50U3RhdGVzOyBwICYmICFwZXJzOyBwID0gcC5uZXh0KVxuICAgICAgaWYgKHNwZWMuc3BlYyA/IGNtcChzcGVjLnNwZWMsIHAuc3BlYykgOiBzcGVjLm1vZGUgPT0gcC5tb2RlKSBwZXJzID0gcDtcbiAgICB2YXIgbW9kZSA9IHBlcnMgPyBwZXJzLm1vZGUgOiBzcGVjLm1vZGUgfHwgQ29kZU1pcnJvci5nZXRNb2RlKGNvbmZpZywgc3BlYy5zcGVjKTtcbiAgICB2YXIgbFN0YXRlID0gcGVycyA/IHBlcnMuc3RhdGUgOiBDb2RlTWlycm9yLnN0YXJ0U3RhdGUobW9kZSk7XG4gICAgaWYgKHNwZWMucGVyc2lzdGVudCAmJiAhcGVycylcbiAgICAgIHN0YXRlLnBlcnNpc3RlbnRTdGF0ZXMgPSB7bW9kZTogbW9kZSwgc3BlYzogc3BlYy5zcGVjLCBzdGF0ZTogbFN0YXRlLCBuZXh0OiBzdGF0ZS5wZXJzaXN0ZW50U3RhdGVzfTtcblxuICAgIHN0YXRlLmxvY2FsU3RhdGUgPSBsU3RhdGU7XG4gICAgc3RhdGUubG9jYWwgPSB7bW9kZTogbW9kZSxcbiAgICAgICAgICAgICAgICAgICBlbmQ6IHNwZWMuZW5kICYmIHRvUmVnZXgoc3BlYy5lbmQpLFxuICAgICAgICAgICAgICAgICAgIGVuZFNjYW46IHNwZWMuZW5kICYmIHNwZWMuZm9yY2VFbmQgIT09IGZhbHNlICYmIHRvUmVnZXgoc3BlYy5lbmQsIGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICBlbmRUb2tlbjogdG9rZW4gJiYgdG9rZW4uam9pbiA/IHRva2VuW3Rva2VuLmxlbmd0aCAtIDFdIDogdG9rZW59O1xuICB9XG5cbiAgZnVuY3Rpb24gaW5kZXhPZih2YWwsIGFycikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBpZiAoYXJyW2ldID09PSB2YWwpIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5kZW50RnVuY3Rpb24oc3RhdGVzLCBtZXRhKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIsIGxpbmUpIHtcbiAgICAgIGlmIChzdGF0ZS5sb2NhbCAmJiBzdGF0ZS5sb2NhbC5tb2RlLmluZGVudClcbiAgICAgICAgcmV0dXJuIHN0YXRlLmxvY2FsLm1vZGUuaW5kZW50KHN0YXRlLmxvY2FsU3RhdGUsIHRleHRBZnRlciwgbGluZSk7XG4gICAgICBpZiAoc3RhdGUuaW5kZW50ID09IG51bGwgfHwgc3RhdGUubG9jYWwgfHwgbWV0YS5kb250SW5kZW50U3RhdGVzICYmIGluZGV4T2Yoc3RhdGUuc3RhdGUsIG1ldGEuZG9udEluZGVudFN0YXRlcykgPiAtMSlcbiAgICAgICAgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcblxuICAgICAgdmFyIHBvcyA9IHN0YXRlLmluZGVudC5sZW5ndGggLSAxLCBydWxlcyA9IHN0YXRlc1tzdGF0ZS5zdGF0ZV07XG4gICAgICBzY2FuOiBmb3IgKDs7KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcnVsZSA9IHJ1bGVzW2ldO1xuICAgICAgICAgIGlmIChydWxlLmRhdGEuZGVkZW50ICYmIHJ1bGUuZGF0YS5kZWRlbnRJZkxpbmVTdGFydCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhciBtID0gcnVsZS5yZWdleC5leGVjKHRleHRBZnRlcik7XG4gICAgICAgICAgICBpZiAobSAmJiBtWzBdKSB7XG4gICAgICAgICAgICAgIHBvcy0tO1xuICAgICAgICAgICAgICBpZiAocnVsZS5uZXh0IHx8IHJ1bGUucHVzaCkgcnVsZXMgPSBzdGF0ZXNbcnVsZS5uZXh0IHx8IHJ1bGUucHVzaF07XG4gICAgICAgICAgICAgIHRleHRBZnRlciA9IHRleHRBZnRlci5zbGljZShtWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIHNjYW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvcyA8IDAgPyAwIDogc3RhdGUuaW5kZW50W3Bvc107XG4gICAgfTtcbiAgfVxufSk7XG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBUZXh0RmlsZVZpZXcsIFdvcmtzcGFjZUxlYWYsIE1hcmtkb3duVmlldyB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IFwiLi9zcmMvbm9yZy1wYXJzZS5qc1wiO1xuaW1wb3J0IFwiLi9saWIvY29kZW1pcnJvci5qc1wiO1xuaW1wb3J0IFwiLi9tb2RlL3NpbXBsZS9zaW1wbGUuanNcIjtcbi8vaW1wb3J0IFwiLi90cmVlLXNpdHRlci1ub3JnLW1haW4vYmluZGluZ3Mvbm9kZS9pbmRleC5qc1wiO1xuXG5pbXBvcnQge1xuICAgIFZpZXdVcGRhdGUsXG4gICAgUGx1Z2luVmFsdWUsXG4gICAgRWRpdG9yVmlldyxcbiAgICBWaWV3UGx1Z2luLFxuICAgIFdpZGdldFR5cGUsXG4gICAgRGVjb3JhdGlvblNldFxufSBmcm9tIFwiQGNvZGVtaXJyb3Ivdmlld1wiO1xuXG5pbXBvcnQgeyB2aW0gfSBmcm9tIFwiQHJlcGxpdC9jb2RlbWlycm9yLXZpbVwiO1xuaW1wb3J0IENvZGVNaXJyb3IgZnJvbSBcIi4vbGliL2NvZGVtaXJyb3IuanNcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVTaW1wbGVNb2RlKFwibmVvcmdcIiwge1xuICAgIHN0YXJ0OiBbXG4gICAgICAgIHsgcmVnZXg6IC9eXFwqIC4qJC8sIHRva2VuOiBbXCJoZWFkZXItMVwiLCBcImhlYWRlclwiXSwgc29sOiB0cnVlIH0sXG4gICAgICAgIHsgcmVnZXg6IC9eXFwqXFwqIC4qLywgdG9rZW46IFtcImhlYWRlci0yXCIsIFwiaGVhZGVyXCJdLCBzb2w6IHRydWUgfSxcbiAgICAgICAgeyByZWdleDogL15cXCpcXCpcXCogLiovLCB0b2tlbjogW1wiaGVhZGVyLTNcIiwgXCJoZWFkZXJcIl0sIHNvbDogdHJ1ZSB9LFxuXG4gICAgICAgIHsgcmVnZXg6IC9eXFxzKlxcfi4qJC8sIHRva2VuOiBbXCJsaXN0LWl0ZW1cIl0sIHNvbDogdHJ1ZSB9LFxuXG4gICAgICAgIHsgcmVnZXg6IFwiXFwvKC4qPylcXC9cIiwgdG9rZW46IFtcIml0YWxpY1wiXSB9LFxuICAgICAgICB7IHJlZ2V4OiAvXFwqKC4qPylcXCovLCB0b2tlbjogW1wiYm9sZFwiXSB9LFxuICAgICAgICB7IHJlZ2V4OiAvYChbXmBdKylgLywgdG9rZW46IFtcImlubGluZS1jb2RlXCJdIH0sXG5cbiAgICAgICAgeyByZWdleDogL15cXHMqLSBcXCggXFwpLywgdG9rZW46IFtcInRvZG9cIl0sIHNvbDogdHJ1ZSB9LFxuICAgICAgICB7IHJlZ2V4OiAvXlxccyotIFxcKHhcXCkvLCB0b2tlbjogW1widG9kb1wiXSwgc29sOiB0cnVlIH0sXG5cbiAgICBdLFxuXG4gICAgZW52OiBbXG4gICAgICAgIHsgcmVnZXg6IC9cXCNcXCsoPzooRU5EfGVuZCkpX1thLXpBLVpdKi8sIHRva2VuOiBcImNvbW1lbnRcIiwgbmV4dDogXCJzdGFydFwiLCBzb2w6IHRydWUgfSxcbiAgICAgICAgeyByZWdleDogLy4qLywgdG9rZW46IFwiY29tbWVudFwiIH1cbiAgICBdXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmVvcmcgZXh0ZW5kcyBQbHVnaW4ge1xuICAgIGFzeW5jIG9ubG9hZCgpIHtcbiAgICAgICAgc3VwZXIub25sb2FkKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGluZyBOZW9yZyBwbHVnaW4gLi4uXCIpO1xuXG4gICAgICAgIHRoaXMucmVnaXN0ZXJWaWV3KFwibmVvcmdcIiwgdGhpcy5uZW9yZ1ZpZXdDcmVhdG9yKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckV4dGVuc2lvbnMoW1wibm9yZ1wiXSwgXCJuZW9yZ1wiKTtcblxuICAgICAgICB0aGlzLmFkZFJpYmJvbkljb24oXCJwbHVzXCIsIFwiTmV3IG5vcmcgZmlsZVwiLCAoKSA9PiB7XG5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmV3TmVvcmdGaWxlKCkge1xuICAgICAgICB0aGlzLmFwcC52YXVsdC5jcmVhdGUoXCJ1bnRpdGxlZDIubm9yZ1wiLCBcIlwiKS50aGVuKGZpbGUgPT4gdGhpcy5hcHAud29ya3NwYWNlLmdldE1vc3RSZWNlbnRMZWFmKCk/Lm9wZW5GaWxlKGZpbGUpKTtcbiAgICB9XG5cbiAgICBuZW9yZ1ZpZXdDcmVhdG9yID0gKGxlYWY6IFdvcmtzcGFjZUxlYWYpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBOZW9yZ1ZpZXcobGVhZik7XG4gICAgfTtcblxuICAgIG9udW5sb2FkKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlVubG9hZGluZyBOZW9yZyBwbHVnaW4gLi4uXCIpO1xuICAgIH1cbn1cblxuY2xhc3MgTmVvcmdWaWV3IGV4dGVuZHMgVGV4dEZpbGVWaWV3IHtcbiAgICAvLyBJbnRlcm5hbCBjb2RlIG1pcnJvciBpbnN0YW5jZTpcbiAgICBjb2RlTWlycm9yOiBDb2RlTWlycm9yLkVkaXRvcjtcbiAgICBkZWNvcmF0aW9uczogRGVjb3JhdGlvblNldDtcblxuICAgIC8vIHRoaXMuY29udGVudEVsIGlzIG5vdCBleHBvc2VkLCBzbyBjaGVhdCBhIGJpdC5cbiAgICBwdWJsaWMgZ2V0IGV4dENvbnRlbnRFbCgpOiBIVE1MRWxlbWVudCB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudEVsO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKGxlYWY6IFdvcmtzcGFjZUxlYWYpIHtcbiAgICAgICAgc3VwZXIobGVhZik7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yID0gQ29kZU1pcnJvcih0aGlzLmV4dENvbnRlbnRFbCwge1xuICAgICAgICAgICAgc2hvd0N1cnNvcldoZW5TZWxlY3Rpbmc6IHRydWUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5vbihcImNoYW5nZXNcIiwgdGhpcy5jaGFuZ2VkKTtcblxuICAgICAgICAvL3RoaXMuY29kZU1pcnJvci5zZXRDdXJzb3IoMCwgMCk7XG4gICAgfVxuXG4gICAgLy8gV2hlbiB0aGUgdmlldyBpcyByZXNpemVkLCByZWZyZXNoIENvZGVNaXJyb3IgKHRoYW5rcyBMaWNhdCEpLlxuICAgIG9uUmVzaXplKCkge1xuICAgICAgICB0aGlzLmNvZGVNaXJyb3IucmVmcmVzaCgpO1xuICAgICAgICB0aGlzLnJlbG9hZEJ1dHRvbnMoKTtcbiAgICB9XG5cbiAgICBjaGFuZ2VkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0aGlzLnJlcXVlc3RTYXZlKCk7XG4gICAgICAgIHRoaXMucmVsb2FkQnV0dG9ucygpO1xuICAgIH07XG5cbiAgICBnZXRWaWV3RGF0YSA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZU1pcnJvci5nZXRWYWx1ZSgpO1xuICAgIH07XG5cbiAgICBzZXRWaWV3RGF0YSA9IChkYXRhOiBzdHJpbmcsIGNsZWFyOiBib29sZWFuKSA9PiB7XG4gICAgICAgIGlmIChjbGVhcikge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnN3YXBEb2MoQ29kZU1pcnJvci5Eb2MoZGF0YSwgXCJuZW9yZ1wiKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0VmFsdWUoZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIC8vaWYgKHRoaXMuYXBwPy52YXVsdD8uY29uZmlnPy52aW1Nb2RlKSB7XG4gICAgICAgIC8vICB0aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwia2V5TWFwXCIsIFwidmltXCIpO1xuICAgICAgICAvL31cblxuICAgICAgICAvLyBUaGlzIHNlZW1zIHRvIGZpeCBzb21lIG9kZCB2aXN1YWwgYnVnczpcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLnJlZnJlc2goKTtcblxuICAgICAgICAvLyBUaGlzIGZvY3VzZXMgdGhlIGVkaXRvciwgd2hpY2ggaXMgYW5hbG9nb3VzIHRvIHRoZVxuICAgICAgICAvLyBkZWZhdWx0IE1hcmtkb3duIGJlaGF2aW9yIGluIE9ic2lkaWFuOlxuICAgICAgICB0aGlzLmNvZGVNaXJyb3IuZm9jdXMoKTtcblxuICAgICAgICB0aGlzLnJlbG9hZEJ1dHRvbnMoKTtcbiAgICB9O1xuXG4gICAgcmVsb2FkQnV0dG9ucyAoKSB7XG4gICAgICAgIGNvbnN0IHRvZG9FbGVtZW50cyA9IHRoaXMuY29udGVudEVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy50b2RvJyk7XG5cbiAgICAvLyBSZW1vdmUgZWFjaCAndG9kbycgZWxlbWVudFxuICAgIHRvZG9FbGVtZW50cy5mb3JFYWNoKHRvZG9FbGVtZW50ID0+IHtcbiAgICAgICAgdG9kb0VsZW1lbnQucmVtb3ZlKCk7XG4gICAgfSk7XG5cbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNvZGVNaXJyb3IuZ2V0V3JhcHBlckVsZW1lbnQoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHRvcFZpc2libGVMaW5lID0gdGhpcy5jb2RlTWlycm9yLmxpbmVBdEhlaWdodChyZWN0LnRvcCwgXCJ3aW5kb3dcIik7XG4gICAgICAgIHZhciBib3R0b21WaXNpYmxlTGluZSA9IHRoaXMuY29kZU1pcnJvci5saW5lQXRIZWlnaHQocmVjdC5ib3R0b20sIFwid2luZG93XCIpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSB0b3BWaXNpYmxlTGluZTsgaSA8IGJvdHRvbVZpc2libGVMaW5lOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0b2tlbnMgPSB0aGlzLmNvZGVNaXJyb3IuZ2V0TGluZVRva2VucyhpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdG9rZW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2Vuc1tqXS50eXBlID09IFwidG9kb1wiKSB7IHRoaXMudG9kb0J1dHRvbih0b2tlbnNbal0sIGkpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gXG4gICAgfVxuXG4gICAgdG9kb0J1dHRvbih0b2tlbiwgbGluZSkge1xuICAgICAgICBsZXQgbGluZXMgPSB0aGlzLmNvbnRlbnRFbC5xdWVyeVNlbGVjdG9yKFwiLkNvZGVNaXJyb3ItbGluZXNcIik7XG4gICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgbGV0IGJ1dHRvbiA9IGxpbmVzLmNyZWF0ZUVsKFwiaW5wdXRcIik7XG4gICAgICAgICAgICBidXR0b24udHlwZSA9IFwiY2hlY2tib3hcIjtcbiAgICAgICAgICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBcInRvZG9cIjtcbiAgICAgICAgICAgIGNvbnN0IGNvb3JkcyA9IHRoaXMuY29kZU1pcnJvci5jaGFyQ29vcmRzKHsgbGluZTogbGluZSwgY2g6IHRva2VuLnN0YXJ0IH0sICdsb2NhbCcpO1xuICAgICAgICAgICAgYnV0dG9uLnN0eWxlLmxlZnQgPSBjb29yZHMubGVmdC50b1N0cmluZygpICsgXCJweFwiO1xuICAgICAgICAgICAgYnV0dG9uLnN0eWxlLnRvcCA9IGNvb3Jkcy50b3AudG9TdHJpbmcoKSArIFwicHhcIjtcbiAgICAgICAgICAgIGJ1dHRvbi5jaGVja2VkID0gdG9rZW4uc3RyaW5nID09IFwiLSAoeClcIjsgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxldCBjbSA9IHRoaXMuY29kZU1pcnJvcjtcbiAgICAgICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VGV4dCA9IGJ1dHRvbi5jaGVja2VkID8gJy0gKHgpJyA6ICctICggKSc7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnJlcGxhY2VSYW5nZShuZXdUZXh0LCB7IGxpbmU6IGxpbmUsIGNoOiB0b2tlbi5zdGFydCB9LCB7IGxpbmU6IGxpbmUsIGNoOiB0b2tlbi5lbmQgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFyID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0VmFsdWUoXCJcIik7XG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5jbGVhckhpc3RvcnkoKTtcbiAgICB9O1xuXG4gICAgZ2V0RGlzcGxheVRleHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGUuYmFzZW5hbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJvcmcgKE5vIEZpbGUpXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjYW5BY2NlcHRFeHRlbnNpb24oZXh0ZW5zaW9uOiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbiA9PT0gXCJub3JnXCI7XG4gICAgfVxuXG4gICAgZ2V0Vmlld1R5cGUoKSB7XG4gICAgICAgIHJldHVybiBcIm5lb3JnXCI7XG4gICAgfVxufVxuXG5jbGFzcyBDaGVja2JveFdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGNoZWNrZWQ6IGJvb2xlYW4pIHsgc3VwZXIoKSB9XG5cbiAgICBlcShvdGhlcjogQ2hlY2tib3hXaWRnZXQpIHsgcmV0dXJuIG90aGVyLmNoZWNrZWQgPT0gdGhpcy5jaGVja2VkIH1cblxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgd3JhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgICAgIHdyYXAuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpXG4gICAgICAgIHdyYXAuY2xhc3NOYW1lID0gXCJjbS1ib29sZWFuLXRvZ2dsZVwiXG4gICAgICAgIGxldCBib3ggPSB3cmFwLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSlcbiAgICAgICAgYm94LnR5cGUgPSBcImNoZWNrYm94XCJcbiAgICAgICAgYm94LmNoZWNrZWQgPSB0aGlzLmNoZWNrZWRcbiAgICAgICAgcmV0dXJuIHdyYXBcbiAgICB9XG5cbiAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlIH1cbn1cblxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUEsK0JBQUFBLFNBQUE7QUFBQSxJQUFBQSxRQUFPLFVBQVU7QUFBQTtBQUFBOzs7QUNBakI7QUFBQSxtQ0FBQUMsU0FBQTtBQUdBLEtBQUMsU0FBUyxLQUFLO0FBQ2IsVUFBSSxPQUFPLFdBQVcsWUFBWSxPQUFPQSxXQUFVO0FBQ2pELFlBQUksb0JBQStCO0FBQUEsZUFDNUIsT0FBTyxVQUFVLGNBQWMsT0FBTztBQUM3QyxlQUFPLENBQUMsc0JBQXNCLEdBQUcsR0FBRztBQUFBO0FBRXBDLFlBQUksVUFBVTtBQUFBLElBQ2xCLEdBQUcsU0FBU0MsYUFBWTtBQUN0QjtBQUVBLE1BQUFBLFlBQVcsbUJBQW1CLFNBQVMsTUFBTSxRQUFRO0FBQ25ELFFBQUFBLFlBQVcsV0FBVyxNQUFNLFNBQVMsUUFBUTtBQUMzQyxpQkFBT0EsWUFBVyxXQUFXLFFBQVEsTUFBTTtBQUFBLFFBQzdDLENBQUM7QUFB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
